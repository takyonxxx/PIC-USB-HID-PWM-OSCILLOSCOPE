CCS PCH C Compiler, Version 4.140, 8195               05-Mar-14 15:40

               Filename:   C:\Users\tbiliyor\Desktop\CurrentProjects\ELECTRO\USB_CONTROL\main.lst

               ROM used:   10984 bytes (34%)
                           Largest free fragment is 21784
               RAM used:   556 (27%) at main() level
                           600 (29%) worst case
               Stack:     15 worst case (6 in main + 9 for interrupts)

*
0000:  GOTO   202A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  FA0.5
0056:  GOTO   0060
005A:  BTFSC  FA1.5
005C:  GOTO   0EB4
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... //printf("DATA: %f %f\r\n", (double) (adc_read1 * 5.0 / 1023.0),(double) (adc_read2 * 5.0 / 1023.0)); 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device ADC=10  
....................  
.................... //configure a 20MHz crystal to operate at 48MHz (USB High speed) 
.................... #fuses NOWDT,NOPROTECT,NOLVP,NODEBUG 
.................... #fuses PLL5    // Divide 20MHz crystal to feed 4MHz to the PLL 
.................... #fuses HSPLL 
.................... #fuses CPUDIV1 // PLL Postscaler divides by 2 ==>  Primary clock = 48 MHz 
.................... #fuses USBDIV  // Use clock from PLL 
.................... #fuses VREGEN    // Enables 3.3V 
....................  
.................... #use delay(clock=48Mhz)  // 48 MHzPrimary Clock comes from PLL Postscaler 
.................... #use rs232(baud=9600,STOP=1, BITS=8, PARITY=N, ERRORS, UART1)   //baud=5050   
*
11B4:  BTFSS  F9E.5
11B6:  BRA    11B4
11B8:  MOVFF  FAB,1A
11BC:  MOVFF  FAE,01
11C0:  BTFSS  1A.1
11C2:  BRA    11C8
11C4:  BCF    FAB.4
11C6:  BSF    FAB.4
11C8:  GOTO   20A0 (RETURN)
.................... #define USB_HID_DEVICE     TRUE               
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_BULK     
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_BULK     
.................... #define USB_EP1_TX_SIZE   128  
.................... #define USB_EP1_RX_SIZE   8     
.................... #include <pic18_usb.h>       
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
.................... #include "USB_18F4550_CONF.h"              
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
....................      const char USB_CLASS_SPECIFIC_DESC[] = { 
....................       6, 0, 255,    // Usage Page = Vendor Defined 
....................       9, 1,            // Usage = IO device 
....................       0xa1, 1,       // Collection = Application 
....................       0x19, 0,        // Usage minimum 
....................       0x29, 800,        // Usage maximum 
....................  
....................       0x15, 0x00,        // Logical minimum (-128) 
....................       0x25, 0xFF,        // Logical maximum (127) 
....................  
....................       0x75, 8,        // Report size = 8 (bits) 
....................       0x95, 128,        // Report count = 16 bits (2 bytes) 
....................       0x81, 2,        // Input (Data, Var, Abs) 
....................       0x19, 0,        // Usage minimum 
....................       0x29, 800,        // Usage maximum 
....................       0x75, 8,        // Report size = 8 (bits) 
....................       0x95, 128,        // Report count = 16 bits (2 bytes) 
....................       0x91, 2,        // Output (Data, Var, Abs) 
....................       0xc0            // End Collection 
....................    }; 
....................  
....................  
....................    //if a class has an extra descriptor not part of the config descriptor, 
....................    // this lookup table defines where to look for it in the const 
....................    // USB_CLASS_SPECIFIC_DESC[] array. 
....................    //first element is the config number (if your device has more than one config) 
....................    //second element is which interface number 
....................    //set element to 0xFFFF if this config/interface combo doesn't exist 
....................    const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP[USB_NUM_CONFIGURATIONS][1] = 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          0 
....................    }; 
....................  
....................    //if a class has an extra descriptor not part of the config descriptor, 
....................    // this lookup table defines the size of that descriptor. 
....................    //first element is the config number (if your device has more than one config) 
....................    //second element is which interface number 
....................    //set element to 0xFFFF if this config/interface combo doesn't exist 
....................    const int16 USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[USB_NUM_CONFIGURATIONS][1] = 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          32 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      41  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==1 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==2 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==3,4 
....................          1, //number of interfaces this device supports       ==5 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==6 
....................          0x00, //index of string descriptor for this configuration      ==7 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==8 
....................          50, //maximum bus power required (maximum milliamperes/2)  (100mA) 
....................  
....................    //interface descriptor 1 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =10 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =11 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==12 
....................          0x00, //alternate setting     ==13 
....................          2, //number of endpoins, except 0 (pic167xx has 3, but we dont have to use all).       ==14 
....................          0x03, //class code, 03 = HID     ==15 
....................          0x00, //subclass code //boot     ==16 
....................          0x00, //protocol code      ==17 
....................          0x00, //index of string descriptor for interface      ==18 
....................  
....................    //class descriptor 1  (HID) 
....................          USB_DESC_CLASS_LEN, //length of descriptor    ==19 
....................          USB_DESC_CLASS_TYPE, //dscriptor type (0x21 == HID)      ==20 
....................          0x11,0x01, //hid class release number (1.0) (try 1.10)      ==21,22 
....................          0x00, //localized country code (0 = none)       ==23 
....................          0x01, //number of hid class descrptors that follow (1)      ==24 
....................          0x22, //report descriptor type (0x22 == HID)                ==25 
....................          USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][0], 0x00, //length of report descriptor            ==26,27 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==28 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==29 
....................          0x81, //endpoint number and direction (0x81 = EP1 IN)       ==30 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==31 
....................          USB_EP1_TX_SIZE,0x00, //maximum packet size supported                  ==32,33 
....................          10,  //polling interval, in ms.  (cant be smaller than 10)      ==34 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==35 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==36 
....................          0x01, //endpoint number and direction (0x01 = EP1 OUT)      ==37 
....................          0x03, //transfer type supported (0x03 is interrupt)         ==38 
....................          USB_EP1_RX_SIZE,0x00, //maximum packet size supported                  ==39,40 
....................          10 //polling interval, in ms.  (cant be smaller than 10)    ==41 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
....................    #define USB_NUM_HID_INTERFACES   1 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   1 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int16 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][1][1]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1 
....................          18 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==1 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==2 
....................          0x00,0x02, //usb version in bcd  
....................          0x00, //class code ==5 
....................          0x00, //subclass code ==6 
....................          0x00, //protocol code ==7 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==8 
....................          0x11,0x11, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??) 
....................          0x11,0x11, //product id   ==11,12  //don't use ffff says usb-by-example guy.  oops 
....................          0x00,0x01, //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==15 
....................          0x02, //index of string descriptor of the product  ==16 
....................          0x00, //index of string descriptor of serial number  ==17 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==18 
....................    }; 
....................  
.................... //0xD8,0x04, //vendor id (0x04D8 is Microchip, or is it 0x0461 ??) 
.................... //0x00,0x0E, //product id   ==11,12  //don't use ffff says usb-by-example guy.  oops 
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          't',0, 
....................          'm',0, 
....................          'c',0, 
....................    //string 2 
....................          58,                   //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          't',0, 
....................          'm',0, 
....................          'c',0, 
....................          'o',0, 
....................          'n',0, 
....................          'e',0, 
....................          ' ',0, 
....................          '(',0, 
....................          'C',0, 
....................          ')',0, 
....................          ' ',0, 
....................          'U',0, 
....................          's',0, 
....................          'b',0, 
....................          'H',0, 
....................          'I',0, 
....................          'D',0, 
....................          ' ',0, 
....................          'U',0, 
....................          'y',0, 
....................          'g',0, 
....................          'u',0, 
....................          'l',0, 
....................          'a',0, 
....................          'm',0, 
....................          'a',0, 
....................          's',0, 
....................          'i',0, 
....................          ' ',0 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #include <usb.c>    
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
*
19FC:  CLRF   03
19FE:  MOVLB  1
1A00:  MOVF   x11,W
1A02:  ADDLW  70
1A04:  MOVWF  FE9
1A06:  MOVLW  0F
1A08:  ADDWFC 03,W
1A0A:  MOVWF  FEA
1A0C:  MOVF   FEF,F
1A0E:  BZ    1A4A
1A10:  CLRF   19
1A12:  BTFSC  FF2.7
1A14:  BSF    19.7
1A16:  BCF    FF2.7
1A18:  CLRF   x3C
1A1A:  MOVFF  111,13B
1A1E:  CLRF   x3E
1A20:  MOVLW  08
1A22:  MOVWF  x3D
1A24:  MOVLB  0
1A26:  CALL   02EE
1A2A:  BTFSC  19.7
1A2C:  BSF    FF2.7
1A2E:  MOVFF  02,113
1A32:  MOVFF  01,112
1A36:  MOVLB  1
1A38:  MOVFF  01,FE9
1A3C:  MOVLW  04
1A3E:  ADDWF  02,W
1A40:  MOVWF  FEA
1A42:  MOVFF  FEF,114
1A46:  BTFSS  x14.7
1A48:  BRA    1A4E
1A4A:  MOVLW  00
1A4C:  BRA    1A50
1A4E:  MOVLW  01
1A50:  MOVWF  01
.................... } 
1A52:  MOVLB  0
1A54:  GOTO   25B8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0BF0:  CLRF   03
0BF2:  MOVLB  1
0BF4:  MOVF   x36,W
0BF6:  ADDLW  70
0BF8:  MOVWF  FE9
0BFA:  MOVLW  0F
0BFC:  ADDWFC 03,W
0BFE:  MOVWF  FEA
0C00:  MOVF   FEF,F
0C02:  BZ    0C3A
0C04:  CLRF   x3C
0C06:  MOVFF  136,13B
0C0A:  CLRF   x3E
0C0C:  MOVLW  08
0C0E:  MOVWF  x3D
0C10:  MOVLB  0
0C12:  CALL   02EE
0C16:  MOVFF  02,138
0C1A:  MOVFF  01,137
0C1E:  MOVLW  04
0C20:  MOVLB  1
0C22:  ADDWF  x37,F
0C24:  MOVLW  00
0C26:  ADDWFC x38,F
0C28:  MOVFF  137,FE9
0C2C:  MOVLW  04
0C2E:  ADDWF  x38,W
0C30:  MOVWF  FEA
0C32:  MOVFF  FEF,139
0C36:  BTFSS  x39.7
0C38:  BRA    0C3E
0C3A:  MOVLW  00
0C3C:  BRA    0C40
0C3E:  MOVLW  01
0C40:  MOVWF  01
.................... } 
0C42:  MOVLB  0
0C44:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
10A2:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
10A4:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
10A6:  MOVLW  08
10A8:  MOVWF  F6F
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
10AA:  MOVF   F94,W
10AC:  IORLW  30
10AE:  MOVLB  1
10B0:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
10B2:  CLRF   23
10B4:  CLRF   19
10B6:  BTFSC  FF2.7
10B8:  BSF    19.7
10BA:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
10BC:  MOVLB  0
10BE:  CALL   039E
10C2:  BTFSC  19.7
10C4:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
10C6:  GOTO   10CC (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
10D0:  CLRF   19
10D2:  BTFSC  FF2.7
10D4:  BSF    19.7
10D6:  BCF    FF2.7
....................    usb_token_reset(); 
10D8:  CALL   039E
10DC:  BTFSC  19.7
10DE:  BSF    FF2.7
....................    UCON = 0; 
10E0:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
10E2:  MOVLW  14
10E4:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
10E6:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
10E8:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
10EA:  MOVLW  01
10EC:  MOVWF  23
.................... } 
10EE:  GOTO   10F8 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
10CA:  BRA    10A2
.................... } 
10CC:  GOTO   1116 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
10F2:  BTFSC  F6D.3
10F4:  BRA    10F8
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
10F6:  BRA    10D0
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
10F8:  DECFSZ 23,W
10FA:  BRA    1112
10FC:  BTFSC  F6D.5
10FE:  BRA    1112
....................    { 
....................       UIR=0; 
1100:  CLRF   F68
....................       UIE=0; 
1102:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
1104:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1106:  MOVLW  C0
1108:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
110A:  MOVLW  11
110C:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
110E:  MOVLW  02
1110:  MOVWF  23
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
1112:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
1114:  BRA    10CA
....................  
....................    do  
....................    { 
....................       usb_task(); 
1116:  RCALL  10F2
....................    } while (usb_state != USB_STATE_POWERED); 
1118:  MOVF   23,W
111A:  SUBLW  02
111C:  BNZ   1116
.................... } 
111E:  GOTO   1142 (RETURN)
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0C46:  MOVFF  131,136
0C4A:  RCALL  0BF0
0C4C:  MOVF   01,F
0C4E:  BTFSC  FD8.2
0C50:  BRA    0D5C
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0C52:  MOVLB  1
0C54:  CLRF   x3C
0C56:  MOVFF  131,13B
0C5A:  CLRF   x3E
0C5C:  MOVLW  08
0C5E:  MOVWF  x3D
0C60:  MOVLB  0
0C62:  CALL   02EE
0C66:  MOVFF  02,137
0C6A:  MOVFF  01,136
0C6E:  MOVLW  04
0C70:  MOVLB  1
0C72:  ADDWF  x36,F
0C74:  MOVLW  00
0C76:  ADDWFC x37,F
0C78:  MOVLW  01
0C7A:  ADDWF  x36,W
0C7C:  MOVWF  01
0C7E:  MOVLW  00
0C80:  ADDWFC x37,W
0C82:  MOVWF  03
0C84:  MOVFF  01,FE9
0C88:  MOVLW  04
0C8A:  ADDWF  03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  132,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0C92:  MOVF   x34,W
0C94:  SUBLW  02
0C96:  BNZ   0CD8
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0C98:  CLRF   x3C
0C9A:  MOVFF  131,13B
0C9E:  CLRF   x3E
0CA0:  MOVLW  08
0CA2:  MOVWF  x3D
0CA4:  MOVLB  0
0CA6:  CALL   02EE
0CAA:  MOVFF  02,137
0CAE:  MOVFF  01,136
0CB2:  MOVLW  04
0CB4:  MOVLB  1
0CB6:  ADDWF  x36,F
0CB8:  MOVLW  00
0CBA:  ADDWFC x37,F
0CBC:  MOVFF  136,FE9
0CC0:  MOVLW  04
0CC2:  ADDWF  x37,W
0CC4:  MOVWF  FEA
0CC6:  MOVFF  FEF,135
....................          if (bit_test(i,6)) 
0CCA:  BTFSS  x35.6
0CCC:  BRA    0CD2
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0CCE:  CLRF   x34
....................          else 
0CD0:  BRA    0CD6
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0CD2:  MOVLW  01
0CD4:  MOVWF  x34
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
0CD6:  BRA    0D0C
0CD8:  MOVF   x34,W
0CDA:  SUBLW  04
0CDC:  BNZ   0D0C
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0CDE:  CLRF   x3C
0CE0:  MOVFF  131,13B
0CE4:  CLRF   x3E
0CE6:  MOVLW  08
0CE8:  MOVWF  x3D
0CEA:  MOVLB  0
0CEC:  CALL   02EE
0CF0:  MOVLB  1
0CF2:  MOVFF  01,FE9
0CF6:  MOVLW  04
0CF8:  ADDWF  02,W
0CFA:  MOVWF  FEA
0CFC:  MOVFF  FEF,135
....................          if (bit_test(i,6)) 
0D00:  BTFSS  x35.6
0D02:  BRA    0D0A
....................             tgl = USB_DTS_DATA1; 
0D04:  MOVLW  01
0D06:  MOVWF  x34
....................          else 
0D08:  BRA    0D0C
....................             tgl = USB_DTS_DATA0; 
0D0A:  CLRF   x34
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0D0C:  DECFSZ x34,W
0D0E:  BRA    0D16
....................          i=0xC8;  //DATA1, UOWN 
0D10:  MOVLW  C8
0D12:  MOVWF  x35
....................       else //if (tgl == USB_DTS_DATA0)  
0D14:  BRA    0D1A
....................          i=0x88; //DATA0, UOWN 
0D16:  MOVLW  88
0D18:  MOVWF  x35
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0D1A:  BTFSC  x33.0
0D1C:  BSF    x35.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0D1E:  BTFSC  x33.1
0D20:  BSF    x35.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0D22:  CLRF   x3C
0D24:  MOVFF  131,13B
0D28:  CLRF   x3E
0D2A:  MOVLW  08
0D2C:  MOVWF  x3D
0D2E:  MOVLB  0
0D30:  CALL   02EE
0D34:  MOVFF  02,137
0D38:  MOVFF  01,136
0D3C:  MOVLW  04
0D3E:  MOVLB  1
0D40:  ADDWF  x36,F
0D42:  MOVLW  00
0D44:  ADDWFC x37,F
0D46:  MOVFF  136,FE9
0D4A:  MOVLW  04
0D4C:  ADDWF  x37,W
0D4E:  MOVWF  FEA
0D50:  MOVFF  135,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0D54:  MOVLW  01
0D56:  MOVWF  01
0D58:  BRA    0D62
....................    } 
....................    else  
0D5A:  MOVLB  0
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0D5C:  MOVLW  00
0D5E:  MOVWF  01
0D60:  MOVLB  1
.................... } 
0D62:  MOVLB  0
0D64:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
.................... { 
*
1D80:  CLRF   19
1D82:  BTFSC  FF2.7
1D84:  BSF    19.7
1D86:  BCF    FF2.7
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
1D88:  MOVFF  111,136
1D8C:  CALL   0BF0
1D90:  BTFSC  19.7
1D92:  BSF    FF2.7
1D94:  MOVF   01,F
1D96:  BZ    1E40
1D98:  CLRF   19
1D9A:  BTFSC  FF2.7
1D9C:  BSF    19.7
1D9E:  BCF    FF2.7
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
1DA0:  MOVLB  1
1DA2:  CLRF   x3C
1DA4:  MOVFF  111,13B
1DA8:  CLRF   x3E
1DAA:  MOVLW  08
1DAC:  MOVWF  x3D
1DAE:  MOVLB  0
1DB0:  CALL   02EE
1DB4:  BTFSC  19.7
1DB6:  BSF    FF2.7
1DB8:  MOVFF  02,11A
1DBC:  MOVFF  01,119
1DC0:  MOVLW  04
1DC2:  MOVLB  1
1DC4:  ADDWF  x19,F
1DC6:  MOVLW  00
1DC8:  ADDWFC x1A,F
1DCA:  MOVLW  02
1DCC:  ADDWF  x19,W
1DCE:  MOVWF  01
1DD0:  MOVLW  00
1DD2:  ADDWFC x1A,W
1DD4:  MOVWF  03
1DD6:  MOVFF  01,FE9
1DDA:  MOVLW  04
1DDC:  ADDWF  03,W
1DDE:  MOVWF  FEA
1DE0:  MOVFF  FEC,118
1DE4:  MOVF   FED,F
1DE6:  MOVFF  FEF,117
....................       memcpy(buff_add, ptr, len);      
1DEA:  MOVFF  118,FEA
1DEE:  MOVFF  117,FE9
1DF2:  MOVFF  113,FE2
1DF6:  MOVFF  112,FE1
1DFA:  MOVFF  115,02
1DFE:  MOVFF  114,01
1E02:  MOVF   01,F
1E04:  BZ    1E0A
1E06:  INCF   02,F
1E08:  BRA    1E0E
1E0A:  MOVF   02,F
1E0C:  BZ    1E1A
1E0E:  MOVFF  FE6,FEE
1E12:  DECFSZ 01,F
1E14:  BRA    1E0E
1E16:  DECFSZ 02,F
1E18:  BRA    1E0E
1E1A:  CLRF   19
1E1C:  BTFSC  FF2.7
1E1E:  BSF    19.7
1E20:  BCF    FF2.7
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
1E22:  MOVFF  111,131
1E26:  MOVFF  115,133
1E2A:  MOVFF  114,132
1E2E:  MOVFF  116,134
1E32:  MOVLB  0
1E34:  CALL   0C46
1E38:  BTFSC  19.7
1E3A:  BSF    FF2.7
1E3C:  MOVF   01,W
1E3E:  BRA    1E44
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
1E40:  MOVLW  00
1E42:  MOVWF  01
.................... } 
1E44:  GOTO   2026 (RETURN)
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
0AF4:  MOVLB  1
0AF6:  CLRF   x3C
0AF8:  MOVFF  131,13B
0AFC:  CLRF   x3E
0AFE:  MOVLW  08
0B00:  MOVWF  x3D
0B02:  MOVLB  0
0B04:  CALL   02EE
0B08:  MOVLB  1
0B0A:  MOVFF  01,FE9
0B0E:  MOVLW  04
0B10:  ADDWF  02,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEF,133
....................    if (tgl == USB_DTS_TOGGLE)  
0B18:  MOVF   x32,W
0B1A:  SUBLW  02
0B1C:  BNZ   0B2A
....................    { 
....................       if (bit_test(i,6)) 
0B1E:  BTFSS  x33.6
0B20:  BRA    0B26
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0B22:  CLRF   x32
....................       else 
0B24:  BRA    0B2A
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0B26:  MOVLW  01
0B28:  MOVWF  x32
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0B2A:  MOVF   x32,W
0B2C:  SUBLW  03
0B2E:  BNZ   0B68
....................    { 
....................       i = 0x84; 
0B30:  MOVLW  84
0B32:  MOVWF  x33
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0B34:  CLRF   x3C
0B36:  MOVFF  131,13B
0B3A:  CLRF   x3E
0B3C:  MOVLW  08
0B3E:  MOVWF  x3D
0B40:  MOVLB  0
0B42:  CALL   02EE
0B46:  MOVFF  02,137
0B4A:  MOVFF  01,136
0B4E:  MOVLW  04
0B50:  MOVLB  1
0B52:  ADDWF  x36,F
0B54:  MOVLW  00
0B56:  ADDWFC x37,F
0B58:  MOVFF  136,FE9
0B5C:  MOVLW  04
0B5E:  ADDWF  x37,W
0B60:  MOVWF  FEA
0B62:  MOVLW  84
0B64:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
0B66:  BRA    0B76
0B68:  DECFSZ x32,W
0B6A:  BRA    0B72
....................       i = 0xC8;  //DATA1, UOWN 
0B6C:  MOVLW  C8
0B6E:  MOVWF  x33
....................    else //if (tgl == USB_DTS_DATA0)  
0B70:  BRA    0B76
....................       i = 0x88; //DATA0, UOWN 
0B72:  MOVLW  88
0B74:  MOVWF  x33
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0B76:  BCF    FD8.0
0B78:  RLCF   x31,W
0B7A:  CLRF   03
0B7C:  MOVLB  0
0B7E:  CALL   00FE
0B82:  TBLRD*+
0B84:  MOVFF  FF5,03
0B88:  MOVLB  1
0B8A:  MOVWF  x34
0B8C:  MOVFF  03,135
....................    EP_BDxCNT_O(endpoint) = len; 
0B90:  CLRF   x3C
0B92:  MOVFF  131,13B
0B96:  CLRF   x3E
0B98:  MOVLW  08
0B9A:  MOVWF  x3D
0B9C:  MOVLB  0
0B9E:  CALL   02EE
0BA2:  MOVFF  01,136
0BA6:  MOVLW  01
0BA8:  MOVLB  1
0BAA:  ADDWF  01,W
0BAC:  MOVWF  01
0BAE:  MOVLW  00
0BB0:  ADDWFC 02,W
0BB2:  MOVWF  03
0BB4:  MOVFF  01,FE9
0BB8:  MOVLW  04
0BBA:  ADDWF  03,W
0BBC:  MOVWF  FEA
0BBE:  MOVFF  134,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0BC2:  BTFSC  x35.0
0BC4:  BSF    x33.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0BC6:  BTFSC  x35.1
0BC8:  BSF    x33.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0BCA:  CLRF   x3C
0BCC:  MOVFF  131,13B
0BD0:  CLRF   x3E
0BD2:  MOVLW  08
0BD4:  MOVWF  x3D
0BD6:  MOVLB  0
0BD8:  CALL   02EE
0BDC:  MOVLB  1
0BDE:  MOVFF  01,FE9
0BE2:  MOVLW  04
0BE4:  ADDWF  02,W
0BE6:  MOVWF  FEA
0BE8:  MOVFF  133,FEF
.................... } 
0BEC:  MOVLB  0
0BEE:  RETURN 0
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
*
1A58:  CLRF   19
1A5A:  BTFSC  FF2.7
1A5C:  BSF    19.7
1A5E:  BCF    FF2.7
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
1A60:  MOVLB  1
1A62:  CLRF   x3C
1A64:  MOVFF  116,13B
1A68:  CLRF   x3E
1A6A:  MOVLW  08
1A6C:  MOVWF  x3D
1A6E:  MOVLB  0
1A70:  CALL   02EE
1A74:  BTFSC  19.7
1A76:  BSF    FF2.7
1A78:  MOVFF  01,120
1A7C:  MOVLW  02
1A7E:  MOVLB  1
1A80:  ADDWF  01,W
1A82:  MOVWF  01
1A84:  MOVLW  00
1A86:  ADDWFC 02,W
1A88:  MOVWF  03
1A8A:  MOVFF  01,FE9
1A8E:  MOVLW  04
1A90:  ADDWF  03,W
1A92:  MOVWF  FEA
1A94:  MOVFF  FEC,11C
1A98:  MOVF   FED,F
1A9A:  MOVFF  FEF,11B
1A9E:  CLRF   19
1AA0:  BTFSC  FF2.7
1AA2:  BSF    19.7
1AA4:  BCF    FF2.7
....................    i = EP_BDxCNT_O(endpoint); 
1AA6:  CLRF   x3C
1AA8:  MOVFF  116,13B
1AAC:  CLRF   x3E
1AAE:  MOVLW  08
1AB0:  MOVWF  x3D
1AB2:  MOVLB  0
1AB4:  CALL   02EE
1AB8:  BTFSC  19.7
1ABA:  BSF    FF2.7
1ABC:  MOVFF  01,120
1AC0:  MOVLW  01
1AC2:  MOVLB  1
1AC4:  ADDWF  01,W
1AC6:  MOVWF  01
1AC8:  MOVLW  00
1ACA:  ADDWFC 02,W
1ACC:  MOVWF  03
1ACE:  MOVFF  01,FE9
1AD2:  MOVLW  04
1AD4:  ADDWF  03,W
1AD6:  MOVWF  FEA
1AD8:  CLRF   x1F
1ADA:  MOVFF  FEF,11E
1ADE:  CLRF   19
1AE0:  BTFSC  FF2.7
1AE2:  BSF    19.7
1AE4:  BCF    FF2.7
....................    st = EP_BDxST_O(endpoint); 
1AE6:  CLRF   x3C
1AE8:  MOVFF  116,13B
1AEC:  CLRF   x3E
1AEE:  MOVLW  08
1AF0:  MOVWF  x3D
1AF2:  MOVLB  0
1AF4:  CALL   02EE
1AF8:  BTFSC  19.7
1AFA:  BSF    FF2.7
1AFC:  MOVLB  1
1AFE:  MOVFF  01,FE9
1B02:  MOVLW  04
1B04:  ADDWF  02,W
1B06:  MOVWF  FEA
1B08:  MOVFF  FEF,11D
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
1B0C:  BTFSC  x1D.0
1B0E:  BSF    x1F.0
....................    if (bit_test(st,1)) {bit_set(i,9);} 
1B10:  BTFSC  x1D.1
1B12:  BSF    x1F.1
....................  
....................    if (i < max) {max = i;} 
1B14:  MOVF   x1F,W
1B16:  SUBWF  x1A,W
1B18:  BNC   1B2A
1B1A:  BNZ   1B22
1B1C:  MOVF   x19,W
1B1E:  SUBWF  x1E,W
1B20:  BC    1B2A
1B22:  MOVFF  11F,11A
1B26:  MOVFF  11E,119
....................     
....................    memcpy(ptr, al ,max); 
1B2A:  MOVFF  118,FEA
1B2E:  MOVFF  117,FE9
1B32:  MOVFF  11C,FE2
1B36:  MOVFF  11B,FE1
1B3A:  MOVFF  11A,02
1B3E:  MOVFF  119,01
1B42:  MOVF   01,F
1B44:  BZ    1B4A
1B46:  INCF   02,F
1B48:  BRA    1B4E
1B4A:  MOVF   02,F
1B4C:  BZ    1B5A
1B4E:  MOVFF  FE6,FEE
1B52:  DECFSZ 01,F
1B54:  BRA    1B4E
1B56:  DECFSZ 02,F
1B58:  BRA    1B4E
....................  
....................    return(max); 
1B5A:  MOVFF  119,01
1B5E:  MOVFF  11A,02
.................... } 
1B62:  MOVLB  0
1B64:  GOTO   1B7E (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
1B68:  MOVFF  111,116
1B6C:  MOVFF  113,118
1B70:  MOVFF  112,117
1B74:  MOVFF  115,11A
1B78:  MOVFF  114,119
1B7C:  BRA    1A58
1B7E:  MOVFF  02,115
1B82:  MOVFF  01,114
1B86:  CLRF   19
1B88:  BTFSC  FF2.7
1B8A:  BSF    19.7
1B8C:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
1B8E:  MOVFF  111,131
1B92:  MOVLW  02
1B94:  MOVLB  1
1B96:  MOVWF  x32
1B98:  MOVLB  0
1B9A:  CALL   0AF4
1B9E:  BTFSC  19.7
1BA0:  BSF    FF2.7
....................  
....................    return(max); 
1BA2:  MOVLB  1
1BA4:  MOVFF  114,01
1BA8:  MOVFF  115,02
.................... } 
1BAC:  MOVLB  0
1BAE:  GOTO   25D6 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0972:  MOVLB  1
0974:  BCF    x32.0
0976:  BTFSC  x31.7
0978:  BSF    x32.0
....................    endpoint &= 0x7F; 
097A:  BCF    x31.7
....................     
....................    if (direction)  
097C:  BTFSS  x32.0
097E:  BRA    09B2
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
0980:  CLRF   x3C
0982:  MOVFF  131,13B
0986:  CLRF   x3E
0988:  MOVLW  08
098A:  MOVWF  x3D
098C:  MOVLB  0
098E:  RCALL  02EE
0990:  MOVFF  02,134
0994:  MOVFF  01,133
0998:  MOVLW  04
099A:  MOVLB  1
099C:  ADDWF  x33,F
099E:  MOVLW  00
09A0:  ADDWFC x34,F
09A2:  MOVFF  133,FE9
09A6:  MOVLW  04
09A8:  ADDWF  x34,W
09AA:  MOVWF  FEA
09AC:  MOVLW  84
09AE:  MOVWF  FEF
....................    } 
....................    else  
09B0:  BRA    09D2
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
09B2:  CLRF   x3C
09B4:  MOVFF  131,13B
09B8:  CLRF   x3E
09BA:  MOVLW  08
09BC:  MOVWF  x3D
09BE:  MOVLB  0
09C0:  RCALL  02EE
09C2:  MOVLB  1
09C4:  MOVFF  01,FE9
09C8:  MOVLW  04
09CA:  ADDWF  02,W
09CC:  MOVWF  FEA
09CE:  MOVLW  84
09D0:  MOVWF  FEF
....................    } 
.................... } 
09D2:  MOVLB  0
09D4:  GOTO   0A82 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
090E:  MOVLB  1
0910:  BCF    x32.0
0912:  BTFSC  x31.7
0914:  BSF    x32.0
....................    endpoint &= 0x7F; 
0916:  BCF    x31.7
....................     
....................    if (direction)  
0918:  BTFSS  x32.0
091A:  BRA    094E
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
091C:  CLRF   x3C
091E:  MOVFF  131,13B
0922:  CLRF   x3E
0924:  MOVLW  08
0926:  MOVWF  x3D
0928:  MOVLB  0
092A:  RCALL  02EE
092C:  MOVFF  02,134
0930:  MOVFF  01,133
0934:  MOVLW  04
0936:  MOVLB  1
0938:  ADDWF  x33,F
093A:  MOVLW  00
093C:  ADDWFC x34,F
093E:  MOVFF  133,FE9
0942:  MOVLW  04
0944:  ADDWF  x34,W
0946:  MOVWF  FEA
0948:  MOVLW  88
094A:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
094C:  BRA    096C
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
094E:  CLRF   x3C
0950:  MOVFF  131,13B
0954:  CLRF   x3E
0956:  MOVLW  08
0958:  MOVWF  x3D
095A:  MOVLB  0
095C:  RCALL  02EE
095E:  MOVLB  1
0960:  MOVFF  01,FE9
0964:  MOVLW  04
0966:  ADDWF  02,W
0968:  MOVWF  FEA
096A:  CLRF   FEF
....................    } 
.................... } 
096C:  MOVLB  0
096E:  GOTO   0A72 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
09D8:  MOVLB  1
09DA:  BCF    x32.0
09DC:  BTFSC  x31.7
09DE:  BSF    x32.0
....................    endpoint &= 0x7F; 
09E0:  BCF    x31.7
....................     
....................    if (direction)  
09E2:  BTFSS  x32.0
09E4:  BRA    0A18
....................    { 
....................       st=EP_BDxST_I(endpoint); 
09E6:  CLRF   x3C
09E8:  MOVFF  131,13B
09EC:  CLRF   x3E
09EE:  MOVLW  08
09F0:  MOVWF  x3D
09F2:  MOVLB  0
09F4:  RCALL  02EE
09F6:  MOVFF  02,135
09FA:  MOVFF  01,134
09FE:  MOVLW  04
0A00:  MOVLB  1
0A02:  ADDWF  x34,F
0A04:  MOVLW  00
0A06:  ADDWFC x35,F
0A08:  MOVFF  134,FE9
0A0C:  MOVLW  04
0A0E:  ADDWF  x35,W
0A10:  MOVWF  FEA
0A12:  MOVFF  FEF,133
....................    } 
....................    else  
0A16:  BRA    0A38
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0A18:  CLRF   x3C
0A1A:  MOVFF  131,13B
0A1E:  CLRF   x3E
0A20:  MOVLW  08
0A22:  MOVWF  x3D
0A24:  MOVLB  0
0A26:  RCALL  02EE
0A28:  MOVLB  1
0A2A:  MOVFF  01,FE9
0A2E:  MOVLW  04
0A30:  ADDWF  02,W
0A32:  MOVWF  FEA
0A34:  MOVFF  FEF,133
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0A38:  BTFSS  x33.7
0A3A:  BRA    0A40
0A3C:  BTFSC  x33.2
0A3E:  BRA    0A44
0A40:  MOVLW  00
0A42:  BRA    0A46
0A44:  MOVLW  01
0A46:  MOVWF  01
.................... } 
0A48:  MOVLB  0
0A4A:  GOTO   0A9A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
0D70:  MOVFF  132,F6E
....................     
....................    if (address)  
0D74:  MOVLB  1
0D76:  MOVF   x32,F
0D78:  BZ    0D80
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0D7A:  MOVLW  04
0D7C:  MOVWF  23
....................    } 
....................    else  
0D7E:  BRA    0D84
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0D80:  MOVLW  02
0D82:  MOVWF  23
....................    } 
.................... } 
0D84:  MOVLB  0
0D86:  GOTO   0D94 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
05D0:  MOVLB  1
05D2:  MOVF   x31,F
05D4:  BNZ   05E2
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
05D6:  MOVLW  04
05D8:  MOVWF  23
....................       usb_disable_endpoints(); 
05DA:  MOVLB  0
05DC:  RCALL  0380
....................    } 
....................    else  
05DE:  BRA    07AE
05E0:  MOVLB  1
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
05E2:  MOVLW  05
05E4:  MOVWF  23
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
05E6:  MOVLW  04
05E8:  MOVWF  x34
05EA:  MOVLW  90
05EC:  MOVWF  x33
....................       for (en=1; en<USB_NUM_UEP; en++)  
05EE:  MOVLW  01
05F0:  MOVWF  x32
05F2:  MOVF   x32,W
05F4:  SUBLW  0F
05F6:  BTFSS  FD8.0
05F8:  BRA    07AE
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
05FA:  MOVFF  132,13A
05FE:  MOVLB  0
0600:  RCALL  0310
....................          new_uep = 0; 
0602:  MOVLB  1
0604:  CLRF   x35
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
0606:  CLRF   03
0608:  MOVF   x32,W
060A:  MOVLB  0
060C:  RCALL  00AE
060E:  SUBLW  FF
0610:  BZ    06DC
....................          { 
....................             new_uep = 0x04; 
0612:  MOVLW  04
0614:  MOVLB  1
0616:  MOVWF  x35
....................             len = usb_ep_rx_size[en]; 
0618:  BCF    FD8.0
061A:  RLCF   x32,W
061C:  CLRF   03
061E:  MOVLB  0
0620:  RCALL  00FE
0622:  TBLRD*+
0624:  MOVFF  FF5,03
0628:  MOVLB  1
062A:  MOVWF  x36
062C:  MOVFF  03,137
....................             EP_BDxCNT_O(en) = len; 
0630:  CLRF   x3C
0632:  MOVFF  132,13B
0636:  CLRF   x3E
0638:  MOVLW  08
063A:  MOVWF  x3D
063C:  MOVLB  0
063E:  RCALL  02EE
0640:  MOVFF  01,139
0644:  MOVLW  01
0646:  MOVLB  1
0648:  ADDWF  01,W
064A:  MOVWF  01
064C:  MOVLW  00
064E:  ADDWFC 02,W
0650:  MOVWF  03
0652:  MOVFF  01,FE9
0656:  MOVLW  04
0658:  ADDWF  03,W
065A:  MOVWF  FEA
065C:  MOVFF  136,FEF
....................             EP_BDxADR_O(en) = addy; 
0660:  CLRF   x3C
0662:  MOVFF  132,13B
0666:  CLRF   x3E
0668:  MOVLW  08
066A:  MOVWF  x3D
066C:  MOVLB  0
066E:  RCALL  02EE
0670:  MOVFF  01,139
0674:  MOVLW  02
0676:  MOVLB  1
0678:  ADDWF  01,W
067A:  MOVWF  01
067C:  MOVLW  00
067E:  ADDWFC 02,W
0680:  MOVWF  03
0682:  MOVFF  01,FE9
0686:  MOVLW  04
0688:  ADDWF  03,W
068A:  MOVWF  FEA
068C:  MOVFF  134,FEC
0690:  MOVF   FED,F
0692:  MOVFF  133,FEF
....................             addy += usb_ep_rx_size[en]; 
0696:  BCF    FD8.0
0698:  RLCF   x32,W
069A:  CLRF   03
069C:  MOVLB  0
069E:  RCALL  00FE
06A0:  TBLRD*+
06A2:  MOVFF  FF5,03
06A6:  MOVLB  1
06A8:  ADDWF  x33,F
06AA:  MOVF   03,W
06AC:  ADDWFC x34,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
06AE:  MOVLW  88
06B0:  MOVWF  x38
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
06B2:  BTFSC  x37.0
06B4:  BSF    x38.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
06B6:  BTFSC  x37.1
06B8:  BSF    x38.1
....................             EP_BDxST_O(en) = i; 
06BA:  CLRF   x3C
06BC:  MOVFF  132,13B
06C0:  CLRF   x3E
06C2:  MOVLW  08
06C4:  MOVWF  x3D
06C6:  MOVLB  0
06C8:  RCALL  02EE
06CA:  MOVLB  1
06CC:  MOVFF  01,FE9
06D0:  MOVLW  04
06D2:  ADDWF  02,W
06D4:  MOVWF  FEA
06D6:  MOVFF  138,FEF
06DA:  MOVLB  0
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
06DC:  CLRF   03
06DE:  MOVLB  1
06E0:  MOVF   x32,W
06E2:  MOVLB  0
06E4:  RCALL  00AE
06E6:  SUBLW  FF
06E8:  BZ    0778
....................          { 
....................             new_uep |= 0x02; 
06EA:  MOVLB  1
06EC:  BSF    x35.1
....................             EP_BDxADR_I(en) = addy; 
06EE:  CLRF   x3C
06F0:  MOVFF  132,13B
06F4:  CLRF   x3E
06F6:  MOVLW  08
06F8:  MOVWF  x3D
06FA:  MOVLB  0
06FC:  RCALL  02EE
06FE:  MOVFF  02,13A
0702:  MOVFF  01,139
0706:  MOVLW  04
0708:  MOVLB  1
070A:  ADDWF  x39,F
070C:  MOVLW  00
070E:  ADDWFC x3A,F
0710:  MOVLW  02
0712:  ADDWF  x39,W
0714:  MOVWF  01
0716:  MOVLW  00
0718:  ADDWFC x3A,W
071A:  MOVWF  03
071C:  MOVFF  01,FE9
0720:  MOVLW  04
0722:  ADDWF  03,W
0724:  MOVWF  FEA
0726:  MOVFF  134,FEC
072A:  MOVF   FED,F
072C:  MOVFF  133,FEF
....................             addy += usb_ep_tx_size[en]; 
0730:  BCF    FD8.0
0732:  RLCF   x32,W
0734:  CLRF   03
0736:  MOVLB  0
0738:  RCALL  00CE
073A:  TBLRD*+
073C:  MOVFF  FF5,03
0740:  MOVLB  1
0742:  ADDWF  x33,F
0744:  MOVF   03,W
0746:  ADDWFC x34,F
....................             EP_BDxST_I(en) = 0x40; 
0748:  CLRF   x3C
074A:  MOVFF  132,13B
074E:  CLRF   x3E
0750:  MOVLW  08
0752:  MOVWF  x3D
0754:  MOVLB  0
0756:  RCALL  02EE
0758:  MOVFF  02,13A
075C:  MOVFF  01,139
0760:  MOVLW  04
0762:  MOVLB  1
0764:  ADDWF  x39,F
0766:  MOVLW  00
0768:  ADDWFC x3A,F
076A:  MOVFF  139,FE9
076E:  MOVLW  04
0770:  ADDWF  x3A,W
0772:  MOVWF  FEA
0774:  MOVLW  40
0776:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
0778:  MOVLB  1
077A:  MOVF   x35,W
077C:  SUBLW  06
077E:  BNZ   0784
0780:  MOVLW  0E
0782:  MOVWF  x35
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
0784:  CLRF   03
0786:  MOVF   x32,W
0788:  MOVLB  0
078A:  RCALL  00AE
078C:  SUBLW  01
078E:  BZ    0796
0790:  MOVLB  1
0792:  BSF    x35.4
0794:  MOVLB  0
....................           
....................          UEP(en) = new_uep; 
0796:  CLRF   03
0798:  MOVLB  1
079A:  MOVF   x32,W
079C:  ADDLW  70
079E:  MOVWF  FE9
07A0:  MOVLW  0F
07A2:  ADDWFC 03,W
07A4:  MOVWF  FEA
07A6:  MOVFF  135,FEF
....................       } 
07AA:  INCF   x32,F
07AC:  BRA    05F2
07AE:  MOVLB  0
....................    } 
.................... } 
07B0:  GOTO   0858 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
0310:  CLRF   03
0312:  MOVLB  1
0314:  MOVF   x3A,W
0316:  ADDLW  70
0318:  MOVWF  FE9
031A:  MOVLW  0F
031C:  ADDWFC 03,W
031E:  MOVWF  FEA
0320:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
0322:  MOVFF  13A,13B
0326:  MOVLB  0
0328:  RCALL  02A0
032A:  MOVF   01,F
032C:  BZ    037E
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
032E:  MOVLB  1
0330:  CLRF   x3C
0332:  MOVFF  13A,13B
0336:  CLRF   x3E
0338:  MOVLW  08
033A:  MOVWF  x3D
033C:  MOVLB  0
033E:  RCALL  02EE
0340:  MOVLB  1
0342:  MOVFF  01,FE9
0346:  MOVLW  04
0348:  ADDWF  02,W
034A:  MOVWF  FEA
034C:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
034E:  CLRF   x3C
0350:  MOVFF  13A,13B
0354:  CLRF   x3E
0356:  MOVLW  08
0358:  MOVWF  x3D
035A:  MOVLB  0
035C:  RCALL  02EE
035E:  MOVFF  02,13C
0362:  MOVFF  01,13B
0366:  MOVLW  04
0368:  MOVLB  1
036A:  ADDWF  x3B,F
036C:  MOVLW  00
036E:  ADDWFC x3C,F
0370:  MOVFF  13B,FE9
0374:  MOVLW  04
0376:  ADDWF  x3C,W
0378:  MOVWF  FEA
037A:  CLRF   FEF
037C:  MOVLB  0
....................    } 
.................... } 
037E:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
0380:  MOVLW  01
0382:  MOVLB  1
0384:  MOVWF  x39
0386:  MOVF   x39,W
0388:  SUBLW  0F
038A:  BNC   039A
....................       usb_disable_endpoint(i); 
038C:  MOVFF  139,13A
0390:  MOVLB  0
0392:  RCALL  0310
0394:  MOVLB  1
0396:  INCF   x39,F
0398:  BRA    0386
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
039A:  MOVLB  0
039C:  RETURN 0
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
.................... } 
0006:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
0EB4:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0EB6:  MOVF   23,F
0EB8:  BNZ   0EBC
0EBA:  BRA    0F38
....................    if (UIR)  
0EBC:  MOVF   F68,F
0EBE:  BZ    0F38
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0EC0:  BTFSS  F68.2
0EC2:  BRA    0ECC
0EC4:  BTFSS  F69.2
0EC6:  BRA    0ECC
0EC8:  GOTO   025A
....................  
....................       if (UCON_SUSPND) return; 
0ECC:  BTFSS  F6D.1
0ECE:  BRA    0ED2
0ED0:  BRA    0F38
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0ED2:  BTFSS  F68.5
0ED4:  BRA    0EDE
0ED6:  BTFSS  F69.5
0ED8:  BRA    0EDE
0EDA:  GOTO   028A
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
0EDE:  BTFSS  F68.1
0EE0:  BRA    0EEA
0EE2:  BTFSS  F69.1
0EE4:  BRA    0EEA
0EE6:  GOTO   0298
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
0EEA:  BTFSS  F68.0
0EEC:  BRA    0EF6
0EEE:  BTFSS  F69.0
0EF0:  BRA    0EF6
0EF2:  GOTO   03CA
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0EF6:  BTFSS  F68.4
0EF8:  BRA    0F02
0EFA:  BTFSS  F69.4
0EFC:  BRA    0F02
0EFE:  GOTO   03F4
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
0F02:  BTFSS  F68.6
0F04:  BRA    0F0E
0F06:  BTFSS  F69.6
0F08:  BRA    0F0E
0F0A:  GOTO   03FE
....................  
....................       TRNAttempts = 0; 
0F0E:  MOVLB  1
0F10:  CLRF   x2E
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
0F12:  BTFSS  F68.3
0F14:  BRA    0F2A
0F16:  BTFSS  F69.3
0F18:  BRA    0F2A
....................          { 
....................             USTATCopy = U1STAT; 
0F1A:  MOVFF  F6C,22
....................             usb_clear_trn(); 
0F1E:  MOVLB  0
0F20:  CALL   0004
....................             usb_isr_tok_dne(); 
0F24:  BRA    0DBC
....................          } 
....................          else 
0F26:  BRA    0F2C
0F28:  MOVLB  1
....................             break; 
0F2A:  BRA    0F36
....................       } while (TRNAttempts++ < 4); 
0F2C:  MOVLB  1
0F2E:  MOVF   x2E,W
0F30:  INCF   x2E,F
0F32:  SUBLW  03
0F34:  BC    0F12
0F36:  MOVLB  0
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
0F38:  GOTO   0060
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
03FE:  BCF    F68.6
.................... } 
0400:  GOTO   0F0E (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
03CA:  CLRF   F6A
....................    UIR = 0; 
03CC:  CLRF   F68
....................    UEIE = 0x9F; 
03CE:  MOVLW  9F
03D0:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
03D2:  MOVLW  3D
03D4:  MOVWF  F69
....................  
....................    UADDR = 0; 
03D6:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
03D8:  RCALL  0380
....................     
....................    usb_token_reset(); 
03DA:  RCALL  039E
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
03DC:  MOVLW  16
03DE:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
03E0:  BTFSS  F68.3
03E2:  BRA    03E8
....................       usb_clear_trn(); 
03E4:  RCALL  0004
....................    } 
03E6:  BRA    03E0
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
03E8:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
03EA:  RCALL  026A
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
03EC:  MOVLW  03
03EE:  MOVWF  23
.................... } 
03F0:  GOTO   0EF6 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
026A:  MOVLW  40
026C:  MOVLB  4
026E:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
0270:  MOVLW  04
0272:  MOVWF  x03
0274:  MOVLW  10
0276:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0278:  MOVLW  88
027A:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
027C:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
027E:  MOVLW  04
0280:  MOVWF  x07
0282:  MOVLW  50
0284:  MOVWF  x06
.................... } 
0286:  MOVLB  0
0288:  RETURN 0
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0298:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
029A:  BCF    F68.1
.................... } 
029C:  GOTO   0EEA (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
03F4:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
03F6:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
03F8:  BSF    F6D.1
.................... } 
03FA:  GOTO   0F02 (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
025A:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
025C:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
025E:  BTFSS  F68.2
0260:  BRA    0266
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
0262:  BCF    F68.2
....................    } 
0264:  BRA    025E
.................... } 
0266:  GOTO   0ECC (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
028A:  BTFSS  F70.0
028C:  BRA    0292
....................    { 
....................       usb_init_ep0_setup(); 
028E:  RCALL  026A
....................       bit_clear(UEP(0), 0); 
0290:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
0292:  BCF    F68.5
.................... } 
0294:  GOTO   0EDE (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0404:  MOVFF  134,24
0408:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
040A:  SETF   24
040C:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0DBC:  RRCF   22,W
0DBE:  MOVLB  1
0DC0:  MOVWF  x2F
0DC2:  RRCF   x2F,F
0DC4:  RRCF   x2F,F
0DC6:  MOVLW  1F
0DC8:  ANDWF  x2F,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0DCA:  MOVF   22,F
0DCC:  BNZ   0E6A
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0DCE:  MOVLB  4
0DD0:  MOVF   x00,W
0DD2:  ANDLW  3C
0DD4:  MOVLB  1
0DD6:  MOVWF  x30
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0DD8:  MOVLW  43
0DDA:  MOVLB  4
0DDC:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0DDE:  MOVLB  1
0DE0:  MOVF   x30,W
0DE2:  SUBLW  34
0DE4:  BNZ   0E30
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0DE6:  MOVLB  4
0DE8:  MOVF   x04,W
0DEA:  ANDLW  80
0DEC:  BZ    0DF0
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0DEE:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0DF0:  MOVLB  0
0DF2:  BRA    0AC2
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0DF4:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0DF6:  INCFSZ 24,W
0DF8:  BRA    0E08
....................             usb_flush_out(0, USB_DTS_STALL); 
0DFA:  MOVLB  1
0DFC:  CLRF   x31
0DFE:  MOVLW  03
0E00:  MOVWF  x32
0E02:  MOVLB  0
0E04:  RCALL  0AF4
....................          else  
0E06:  BRA    0E2C
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0E08:  MOVLB  1
0E0A:  CLRF   x31
0E0C:  MOVLW  02
0E0E:  MOVWF  x32
0E10:  MOVLB  0
0E12:  RCALL  0AF4
....................             if (__setup_0_tx_size != 0xFE) 
0E14:  MOVF   24,W
0E16:  SUBLW  FE
0E18:  BZ    0E2C
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0E1A:  MOVLB  1
0E1C:  CLRF   x31
0E1E:  CLRF   x33
0E20:  MOVFF  24,132
0E24:  MOVLW  04
0E26:  MOVWF  x34
0E28:  MOVLB  0
0E2A:  RCALL  0C46
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
0E2C:  BRA    0E66
0E2E:  MOVLB  1
0E30:  MOVF   x30,W
0E32:  SUBLW  04
0E34:  BNZ   0E68
....................       { 
....................          usb_isr_tok_out_dne(0); 
0E36:  CLRF   x31
0E38:  MOVLB  0
0E3A:  RCALL  0D66
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0E3C:  MOVLB  1
0E3E:  CLRF   x31
0E40:  MOVLW  02
0E42:  MOVWF  x32
0E44:  MOVLB  0
0E46:  RCALL  0AF4
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0E48:  MOVF   24,W
0E4A:  SUBLW  FE
0E4C:  BZ    0E66
0E4E:  INCFSZ 24,W
0E50:  BRA    0E54
0E52:  BRA    0E66
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0E54:  MOVLB  1
0E56:  CLRF   x31
0E58:  CLRF   x33
0E5A:  MOVFF  24,132
0E5E:  MOVLW  01
0E60:  MOVWF  x34
0E62:  MOVLB  0
0E64:  RCALL  0C46
....................          } 
....................       } 
....................       else 
0E66:  MOVLB  1
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
0E68:  BRA    0EAE
0E6A:  MOVF   22,W
0E6C:  SUBLW  04
0E6E:  BNZ   0E94
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
0E70:  SETF   24
....................       usb_isr_tok_in_dne(0); 
0E72:  CLRF   x31
0E74:  MOVLB  0
0E76:  RCALL  0D98
....................       if (__setup_0_tx_size!=0xFF) 
0E78:  INCFSZ 24,W
0E7A:  BRA    0E7E
0E7C:  BRA    0E90
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0E7E:  MOVLB  1
0E80:  CLRF   x31
0E82:  CLRF   x33
0E84:  MOVFF  24,132
0E88:  MOVLW  02
0E8A:  MOVWF  x34
0E8C:  MOVLB  0
0E8E:  RCALL  0C46
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
0E90:  BRA    0EAC
0E92:  MOVLB  1
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0E94:  BTFSC  22.2
0E96:  BRA    0EA4
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
0E98:  MOVFF  12F,131
0E9C:  MOVLB  0
0E9E:  RCALL  0D66
....................       } 
....................       else  
0EA0:  BRA    0EAC
0EA2:  MOVLB  1
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
0EA4:  MOVFF  12F,131
0EA8:  MOVLB  0
0EAA:  RCALL  0D98
0EAC:  MOVLB  1
....................       } 
....................    } 
.................... } 
0EAE:  MOVLB  0
0EB0:  GOTO   0F26 (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
112E:  MOVF   1C,W
1130:  MOVWF  01
.................... } 
1132:  GOTO   1152 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
*
1122:  MOVF   1C,F
1124:  BNZ   112A
1126:  CLRWDT
1128:  BRA    1122
.................... } 
112A:  GOTO   1150 (RETURN)
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
039E:  CLRF   29
03A0:  CLRF   28
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
03A2:  MOVLB  1
03A4:  CLRF   x2F
03A6:  MOVF   x2F,F
03A8:  BNZ   03BE
....................       USB_Interface[i] = 0;   //reset each interface to default 
03AA:  CLRF   03
03AC:  MOVF   x2F,W
03AE:  ADDLW  2A
03B0:  MOVWF  FE9
03B2:  MOVLW  00
03B4:  ADDWFC 03,W
03B6:  MOVWF  FEA
03B8:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
03BA:  INCF   x2F,F
03BC:  BRA    03A6
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
03BE:  CLRF   1C
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
03C0:  MOVLW  01
03C2:  MOVWF  1D
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
03C4:  CLRF   1B
.................... } 
03C6:  MOVLB  0
03C8:  RETURN 0
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
02A0:  MOVLB  1
02A2:  BCF    x3C.0
02A4:  BTFSC  x3B.7
02A6:  BSF    x3C.0
....................     
....................    endpoint &= 0x7F; 
02A8:  BCF    x3B.7
....................     
....................    if (endpoint > 16) 
02AA:  MOVF   x3B,W
02AC:  SUBLW  10
02AE:  BC    02B6
....................       return(FALSE); 
02B0:  MOVLW  00
02B2:  MOVWF  01
02B4:  BRA    02EA
....................     
....................    if (direction) { //IN 
02B6:  BTFSS  x3C.0
02B8:  BRA    02D4
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
02BA:  CLRF   03
02BC:  MOVF   x3B,W
02BE:  MOVLB  0
02C0:  RCALL  00AE
02C2:  SUBLW  FF
02C4:  BNZ   02CA
02C6:  MOVLW  00
02C8:  BRA    02CC
02CA:  MOVLW  01
02CC:  MOVWF  01
02CE:  MOVLB  1
02D0:  BRA    02EA
....................    } 
....................    else {   //OUT 
02D2:  BRA    02EA
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
02D4:  CLRF   03
02D6:  MOVF   x3B,W
02D8:  MOVLB  0
02DA:  RCALL  00AE
02DC:  SUBLW  FF
02DE:  BNZ   02E4
02E0:  MOVLW  00
02E2:  BRA    02E6
02E4:  MOVLW  01
02E6:  MOVWF  01
02E8:  MOVLB  1
....................    } 
.................... } 
02EA:  MOVLB  0
02EC:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
0D98:  MOVLB  1
0D9A:  MOVF   x31,F
0D9C:  BNZ   0DB8
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0D9E:  DECFSZ 1B,W
0DA0:  BRA    0DAC
0DA2:  MOVLB  0
0DA4:  CALL   040E
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0DA8:  BRA    0DB6
0DAA:  MOVLB  1
0DAC:  MOVF   1B,W
0DAE:  SUBLW  02
0DB0:  BNZ   0DB8
0DB2:  MOVLB  0
0DB4:  BRA    0D8A
0DB6:  MOVLB  1
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
0DB8:  MOVLB  0
0DBA:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0D66:  MOVLB  1
0D68:  MOVF   x31,F
0D6A:  BNZ   0D6C
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
0D6C:  MOVLB  0
0D6E:  RETURN 0
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
0AC2:  CLRF   1B
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
0AC4:  MOVLB  4
0AC6:  MOVF   x10,W
0AC8:  ANDLW  7F
0ACA:  XORLW  00
0ACC:  MOVLB  0
0ACE:  BZ    0ADE
0AD0:  XORLW  01
0AD2:  BZ    0AE2
0AD4:  XORLW  03
0AD6:  BZ    0AE6
0AD8:  XORLW  23
0ADA:  BZ    0AEA
0ADC:  BRA    0AEE
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
0ADE:  BRA    07B4
....................          break; 
0AE0:  BRA    0AF0
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
0AE2:  BRA    086A
....................          break; 
0AE4:  BRA    0AF0
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
0AE6:  BRA    0A4E
....................          break; 
0AE8:  BRA    0AF0
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
0AEA:  BRA    0AB6
....................         #else 
....................          usb_isr_tkn_cdc(); 
....................         #endif 
....................          break; 
0AEC:  BRA    0AF0
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
0AEE:  RCALL  040A
....................          break; 
....................    } 
.................... } 
0AF0:  GOTO   0DF4 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
07B4:  MOVLB  4
07B6:  MOVF   x11,W
07B8:  XORLW  00
07BA:  MOVLB  0
07BC:  BZ    07D8
07BE:  XORLW  01
07C0:  BZ    07EC
07C2:  XORLW  02
07C4:  BZ    0806
07C6:  XORLW  06
07C8:  BZ    081E
07CA:  XORLW  03
07CC:  BZ    0830
07CE:  XORLW  0E
07D0:  BZ    0834
07D2:  XORLW  01
07D4:  BZ    0844
07D6:  BRA    0864
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
07D8:  MOVFF  1D,450
....................             usb_ep0_tx_buffer[1]=0; 
07DC:  MOVLB  4
07DE:  CLRF   x51
....................             usb_request_send_response(2); 
07E0:  MOVLW  02
07E2:  MOVLB  1
07E4:  MOVWF  x34
07E6:  MOVLB  0
07E8:  RCALL  0404
....................             break; 
07EA:  BRA    0866
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
07EC:  MOVLB  4
07EE:  DECFSZ x12,W
07F0:  BRA    0800
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
07F2:  MOVLW  01
07F4:  ANDWF  1D,F
....................                usb_put_0len_0(); 
07F6:  MOVLB  1
07F8:  CLRF   x34
07FA:  MOVLB  0
07FC:  RCALL  0404
....................             } 
....................             else 
07FE:  BRA    0804
....................                usb_request_stall(); 
0800:  MOVLB  0
0802:  RCALL  040A
....................             break; 
0804:  BRA    0866
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0806:  MOVLB  4
0808:  DECFSZ x12,W
080A:  BRA    0818
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
080C:  BSF    1D.1
....................                usb_put_0len_0(); 
080E:  MOVLB  1
0810:  CLRF   x34
0812:  MOVLB  0
0814:  RCALL  0404
....................             } 
....................             else 
0816:  BRA    081C
....................                usb_request_stall(); 
0818:  MOVLB  0
081A:  RCALL  040A
....................             break; 
081C:  BRA    0866
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
081E:  MOVLW  02
0820:  MOVWF  1B
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
0822:  MOVFF  412,25
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
0826:  MOVLB  1
0828:  CLRF   x34
082A:  MOVLB  0
082C:  RCALL  0404
....................             break; 
082E:  BRA    0866
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
0830:  RCALL  04CC
....................             break; 
0832:  BRA    0866
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
0834:  MOVFF  1C,450
....................             usb_request_send_response(1); 
0838:  MOVLW  01
083A:  MOVLB  1
083C:  MOVWF  x34
083E:  MOVLB  0
0840:  RCALL  0404
....................             break; 
0842:  BRA    0866
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
0844:  MOVLB  4
0846:  MOVF   x12,W
0848:  SUBLW  01
084A:  BNC   0860
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
084C:  MOVFF  412,1C
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
0850:  MOVFF  412,131
0854:  MOVLB  0
0856:  BRA    05D0
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
0858:  MOVLB  1
085A:  CLRF   x34
085C:  MOVLB  0
085E:  RCALL  0404
....................             } 
....................             break; 
0860:  MOVLB  0
0862:  BRA    0866
....................  
....................       default: 
....................             usb_request_stall(); 
0864:  RCALL  040A
....................             break; 
....................    } 
.................... } 
0866:  GOTO   0AF0 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
086A:  MOVFF  1C,131
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
086E:  MOVLB  4
0870:  MOVF   x11,W
0872:  XORLW  00
0874:  MOVLB  0
0876:  BZ    0886
0878:  XORLW  0A
087A:  BZ    0898
087C:  XORLW  01
087E:  BZ    08DA
0880:  XORLW  0D
0882:  BZ    0904
0884:  BRA    0908
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
0886:  MOVLB  4
0888:  CLRF   x50
....................             usb_ep0_tx_buffer[1]=0; 
088A:  CLRF   x51
....................             usb_request_send_response(2); 
088C:  MOVLW  02
088E:  MOVLB  1
0890:  MOVWF  x34
0892:  MOVLB  0
0894:  RCALL  0404
....................             break; 
0896:  BRA    090A
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
0898:  MOVLB  1
089A:  MOVF   x31,F
089C:  BZ    08D4
089E:  MOVLW  01
08A0:  SUBWF  x31,W
08A2:  CLRF   03
08A4:  MOVLB  0
08A6:  RCALL  01BC
08A8:  MOVWF  01
08AA:  MOVLB  4
08AC:  SUBWF  x14,W
08AE:  BTFSS  FD8.0
08B0:  BRA    08B6
08B2:  MOVLB  1
08B4:  BRA    08D4
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
08B6:  CLRF   03
08B8:  MOVF   x14,W
08BA:  ADDLW  2A
08BC:  MOVWF  FE9
08BE:  MOVLW  00
08C0:  ADDWFC 03,W
08C2:  MOVWF  FEA
08C4:  MOVFF  FEF,450
....................                usb_request_send_response(1);; //send byte back 
08C8:  MOVLW  01
08CA:  MOVLB  1
08CC:  MOVWF  x34
08CE:  MOVLB  0
08D0:  RCALL  0404
....................             } 
....................             else 
08D2:  BRA    08D8
....................                usb_request_stall(); 
08D4:  MOVLB  0
08D6:  RCALL  040A
....................             break; 
08D8:  BRA    090A
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
08DA:  MOVLB  1
08DC:  MOVF   x31,F
08DE:  BZ    08FE
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
08E0:  CLRF   03
08E2:  MOVLB  4
08E4:  MOVF   x14,W
08E6:  ADDLW  2A
08E8:  MOVWF  FE9
08EA:  MOVLW  00
08EC:  ADDWFC 03,W
08EE:  MOVWF  FEA
08F0:  MOVFF  412,FEF
....................                usb_put_0len_0(); 
08F4:  MOVLB  1
08F6:  CLRF   x34
08F8:  MOVLB  0
08FA:  RCALL  0404
....................             } 
....................             else 
08FC:  BRA    0902
....................                usb_request_stall(); 
08FE:  MOVLB  0
0900:  RCALL  040A
....................             break; 
0902:  BRA    090A
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
0904:  RCALL  04CC
....................             break; 
0906:  BRA    090A
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
0908:  RCALL  040A
....................             break; 
....................    } 
.................... } 
090A:  GOTO   0AF0 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
0A4E:  MOVFF  414,13B
0A52:  RCALL  02A0
0A54:  MOVF   01,F
0A56:  BZ    0AB2
....................       switch(usb_ep0_rx_buffer[1]) { 
0A58:  MOVLB  4
0A5A:  MOVF   x11,W
0A5C:  XORLW  01
0A5E:  MOVLB  0
0A60:  BZ    0A6C
0A62:  XORLW  02
0A64:  BZ    0A7C
0A66:  XORLW  03
0A68:  BZ    0A8C
0A6A:  BRA    0AB0
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0A6C:  MOVFF  414,131
0A70:  BRA    090E
....................                usb_put_0len_0(); 
0A72:  MOVLB  1
0A74:  CLRF   x34
0A76:  MOVLB  0
0A78:  RCALL  0404
....................                break; 
0A7A:  BRA    0AB2
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0A7C:  MOVFF  414,131
0A80:  BRA    0972
....................                      usb_put_0len_0(); 
0A82:  MOVLB  1
0A84:  CLRF   x34
0A86:  MOVLB  0
0A88:  RCALL  0404
....................                      break; 
0A8A:  BRA    0AB2
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
0A8C:  MOVLB  4
0A8E:  CLRF   x50
....................                usb_ep0_tx_buffer[1]=0; 
0A90:  CLRF   x51
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0A92:  MOVFF  414,131
0A96:  MOVLB  0
0A98:  BRA    09D8
0A9A:  MOVF   01,F
0A9C:  BZ    0AA4
....................                   usb_ep0_tx_buffer[0]=1; 
0A9E:  MOVLW  01
0AA0:  MOVLB  4
0AA2:  MOVWF  x50
....................                } 
....................                usb_request_send_response(2); 
0AA4:  MOVLW  02
0AA6:  MOVLB  1
0AA8:  MOVWF  x34
0AAA:  MOVLB  0
0AAC:  RCALL  0404
....................                break; 
0AAE:  BRA    0AB2
....................  
....................          default: 
....................             usb_request_stall(); 
0AB0:  RCALL  040A
....................             break; 
....................       } 
....................    } 
.................... } 
0AB2:  GOTO   0AF0 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
0AB6:  MOVLB  4
0AB8:  MOVF   x11,W
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
0ABA:  MOVLB  0
0ABC:  RCALL  040A
....................             break; 
....................    } 
.................... } 
0ABE:  GOTO   0AF0 (RETURN)
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
04CC:  CLRF   27
04CE:  CLRF   26
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
04D0:  CLRF   1E
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
04D2:  MOVLB  4
04D4:  MOVF   x13,W
04D6:  XORLW  01
04D8:  MOVLB  0
04DA:  BZ    04EE
04DC:  XORLW  03
04DE:  BZ    04FA
04E0:  XORLW  01
04E2:  BZ    0502
04E4:  XORLW  22
04E6:  BZ    0530
04E8:  XORLW  03
04EA:  BZ    0568
04EC:  BRA    05AC
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
04EE:  CLRF   29
04F0:  MOVLW  12
04F2:  MOVWF  28
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
04F4:  MOVLW  03
04F6:  MOVWF  1E
....................             break; 
04F8:  BRA    05B0
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
04FA:  CLRF   29
04FC:  MOVLW  29
04FE:  MOVWF  28
....................             break; 
0500:  BRA    05B0
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0502:  MOVLW  02
0504:  MOVWF  1E
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
0506:  CLRF   03
0508:  MOVLB  4
050A:  MOVF   x12,W
050C:  ADDLW  1F
050E:  MOVWF  FE9
0510:  MOVLW  00
0512:  ADDWFC 03,W
0514:  MOVWF  FEA
0516:  CLRF   27
0518:  MOVFF  FEF,26
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
051C:  MOVFF  27,03
0520:  MOVF   26,W
0522:  MOVLB  0
0524:  RCALL  0202
0526:  CLRF   03
0528:  MOVWF  28
052A:  MOVFF  03,29
....................             break; 
052E:  BRA    05B0
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
0530:  BCF    FD8.0
0532:  MOVLB  4
0534:  RLCF   x12,W
0536:  CLRF   03
0538:  MOVLB  0
053A:  RCALL  01CE
053C:  TBLRD*+
053E:  MOVFF  FF5,03
0542:  MOVWF  26
0544:  MOVFF  03,27
....................             if (usb_getdesc_ptr!=0xFF) { 
0548:  INCFSZ 26,W
054A:  BRA    0550
054C:  MOVF   27,F
054E:  BZ    0564
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0550:  MOVFF  27,03
0554:  MOVF   26,W
0556:  RCALL  0182
0558:  CLRF   03
055A:  MOVWF  28
055C:  MOVFF  03,29
....................                break; 
0560:  BRA    05B0
....................             } 
....................             else { 
0562:  BRA    0568
....................                usb_request_stall(); 
0564:  RCALL  040A
....................                return; 
0566:  BRA    05CE
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
0568:  BCF    FD8.0
056A:  MOVLB  4
056C:  RLCF   x14,W
056E:  CLRF   03
0570:  MOVLB  0
0572:  RCALL  015E
0574:  TBLRD*+
0576:  MOVFF  FF5,03
057A:  MOVWF  26
057C:  MOVFF  03,27
....................             if (usb_getdesc_ptr !=0xFF) { 
0580:  INCFSZ 26,W
0582:  BRA    0588
0584:  MOVF   27,F
0586:  BZ    05A8
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
0588:  MOVLW  01
058A:  MOVWF  1E
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
058C:  BCF    FD8.0
058E:  MOVLB  4
0590:  RLCF   x14,W
0592:  CLRF   03
0594:  MOVLB  0
0596:  RCALL  0170
0598:  TBLRD*+
059A:  MOVFF  FF5,03
059E:  MOVWF  28
05A0:  MOVFF  03,29
....................                break; 
05A4:  BRA    05B0
....................             } 
....................             else { 
05A6:  BRA    05AC
....................                usb_request_stall(); 
05A8:  RCALL  040A
....................                return; 
05AA:  BRA    05CE
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
05AC:  RCALL  040A
....................             return; 
05AE:  BRA    05CE
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
05B0:  MOVLB  4
05B2:  MOVF   x17,F
05B4:  BNZ   05C6
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
05B6:  MOVF   29,F
05B8:  BNZ   05C0
05BA:  MOVF   28,W
05BC:  SUBWF  x16,W
05BE:  BC    05C6
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
05C0:  CLRF   29
05C2:  MOVFF  416,28
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
05C6:  MOVLW  01
05C8:  MOVWF  1B
....................    usb_copy_desc_seg_to_ep(); 
05CA:  MOVLB  0
05CC:  RCALL  040E
.................... } 
05CE:  RETURN 0
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0D8A:  CLRF   1C
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0D8C:  CLRF   1B
....................    usb_set_address(USB_address_pending); 
0D8E:  MOVFF  25,132
0D92:  BRA    0D70
....................    #endif 
.................... } 
0D94:  GOTO   0DB6 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
040E:  MOVLB  1
0410:  CLRF   x32
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
0412:  MOVF   28,W
0414:  IORWF  29,W
0416:  BZ    0492
0418:  MOVF   x32,W
041A:  SUBLW  3F
041C:  BNC   0492
....................       switch(USB_stack_status.getdesc_type) { 
041E:  MOVF   1E,W
0420:  ADDLW  FC
0422:  BC    046E
0424:  ADDLW  04
0426:  MOVLB  0
0428:  GOTO   04AA
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
042C:  MOVFF  27,03
0430:  MOVF   26,W
0432:  RCALL  0182
0434:  MOVFF  FE8,133
....................             break; 
0438:  MOVLB  1
043A:  BRA    046E
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
043C:  MOVFF  27,03
0440:  MOVF   26,W
0442:  RCALL  012E
0444:  MOVFF  FE8,133
....................             break; 
0448:  MOVLB  1
044A:  BRA    046E
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
044C:  MOVFF  27,03
0450:  MOVF   26,W
0452:  RCALL  0202
0454:  MOVFF  FE8,133
....................             break; 
0458:  MOVLB  1
045A:  BRA    046E
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
045C:  MOVFF  27,03
0460:  MOVF   26,W
0462:  RCALL  01E0
0464:  MOVFF  FE8,133
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
0468:  MOVLB  1
046A:  BRA    046E
046C:  MOVLB  1
....................       } 
....................       usb_getdesc_ptr++; 
046E:  INCF   26,F
0470:  BTFSC  FD8.2
0472:  INCF   27,F
....................       usb_getdesc_len--; 
0474:  MOVF   28,W
0476:  BTFSC  FD8.2
0478:  DECF   29,F
047A:  DECF   28,F
....................       usb_ep0_tx_buffer[i++]=c; 
047C:  MOVF   x32,W
047E:  INCF   x32,F
0480:  ADDLW  50
0482:  MOVWF  FE9
0484:  MOVLW  04
0486:  MOVWF  FEA
0488:  BTFSC  FD8.0
048A:  INCF   FEA,F
048C:  MOVFF  133,FEF
....................    } 
0490:  BRA    0412
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
0492:  MOVF   28,W
0494:  IORWF  29,W
0496:  BNZ   04A0
0498:  MOVF   x32,W
049A:  SUBLW  40
049C:  BZ    04A0
....................          USB_stack_status.dev_req = NONE; 
049E:  CLRF   1B
....................    } 
....................  
....................    usb_request_send_response(i); 
04A0:  MOVFF  132,134
04A4:  MOVLB  0
04A6:  RCALL  0404
.................... } 
04A8:  RETURN 0
....................  
.................... #ENDIF 
....................  
.................... #use FAST_IO(A)         // I/O dir doesn't change when 
.................... #use FAST_IO(B)         // reading and writing to ports 
.................... #use FAST_IO(C) 
.................... #use FAST_IO(D) 
.................... unsigned int8 datain[8]; 
.................... unsigned int8 dataout[8]; 
.................... static unsigned int16 adc_read = 0; 
.................... static unsigned int16 pwmfreq = 255; 
.................... static unsigned int16 pwmduty = 128; 
.................... static unsigned int16 channel = 0; 
.................... static unsigned int16 pwmmode = 16; 
.................... int32 xtalfreq = 48000000;   
.................... unsigned int pwm1; 
.................... unsigned int x;  
.................... int i=0,r=0; 
.................... int al=1; 
.................... float floatveri; 
.................... char seri[7],veri; 
.................... char serial(); 
.................... void serigonder(); 
.................... float adc1,adc2,adc3,adc4,adc5,adc6,adc7,adc8,adc9,adc10,adc11,adc12,adc; 
.................... float readadc(int port); 
.................... char gonderilecekveri[128]; 
.................... void try_usb(void)  
.................... {  
....................    printf("USB Connecting\r");   
*
1136:  MOVLW  3C
1138:  MOVWF  FF6
113A:  MOVLW  0F
113C:  MOVWF  FF7
113E:  RCALL  1080
....................    usb_init();   
1140:  BRA    1114
....................    usb_task(); 
1142:  RCALL  10F2
....................    printf("Wait_for_enumeration\r");         
1144:  MOVLW  4C
1146:  MOVWF  FF6
1148:  MOVLW  0F
114A:  MOVWF  FF7
114C:  RCALL  1080
....................    usb_wait_for_enumeration(); 
114E:  BRA    1122
....................    if(usb_enumerated())  
1150:  BRA    112E
1152:  MOVF   01,F
1154:  BZ    1162
....................    printf("USB Connected\r");   
1156:  MOVLW  62
1158:  MOVWF  FF6
115A:  MOVLW  0F
115C:  MOVWF  FF7
115E:  RCALL  1080
....................    else 
1160:  BRA    116C
....................    printf("USB Not Connected\r");  
1162:  MOVLW  72
1164:  MOVWF  FF6
1166:  MOVLW  0F
1168:  MOVWF  FF7
116A:  RCALL  1080
.................... }  
116C:  RETURN 0
.................... void user_init(void)  
.................... {  
....................    //disable_interrupts(GLOBAL);   
....................    set_tris_a(0xff); 
116E:  MOVLW  FF
1170:  MOVWF  F92
....................    set_tris_b(0xff); 
1172:  MOVWF  F93
....................    set_tris_e(0xff); 
1174:  MOVWF  F96
....................    set_tris_c(0b10000000); 
1176:  MOVLW  80
1178:  MOVWF  F94
....................    setup_CCP1(CCP_PWM); 
117A:  BCF    F8B.2
117C:  MOVLW  0C
117E:  MOVWF  FBD
1180:  CLRF   FB7
1182:  CLRF   FB6
....................    setup_adc_ports(ALL_ANALOG);  // A0 A1 A2 A3 A5 E0 E1 E2 B2 B3 B1 B4 B0   
1184:  MOVF   FC1,W
1186:  ANDLW  C0
1188:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_DIV_8);  
118A:  MOVF   FC0,W
118C:  ANDLW  C0
118E:  IORLW  01
1190:  MOVWF  FC0
1192:  BSF    FC0.7
1194:  BSF    FC2.0
....................    setup_ccp1(CCP_PWM);  // Configure CCP1 as a PWM     
1196:  BCF    F8B.2
1198:  MOVLW  0C
119A:  MOVWF  FBD
119C:  CLRF   FB7
119E:  CLRF   FB6
....................    enable_interrupts(GLOBAL); 
11A0:  MOVLW  C0
11A2:  IORWF  FF2,F
....................    printf("PIC18F4550 READY\r");    
11A4:  MOVLW  86
11A6:  MOVWF  FF6
11A8:  MOVLW  0F
11AA:  MOVWF  FF7
11AC:  RCALL  1080
....................    try_usb(); 
11AE:  RCALL  1136
.................... }  
11B0:  GOTO   2098 (RETURN)
.................... int32 getFreq(int16 pwnfreq, int16 timediv) 
.................... {   
....................    return (int32)xtalfreq /(timediv * (pwnfreq + 1) * 4);  
*
176C:  MOVLW  01
176E:  MOVLB  1
1770:  ADDWF  x11,W
1772:  MOVWF  01
1774:  MOVLW  00
1776:  ADDWFC x12,W
1778:  MOVWF  03
177A:  MOVFF  01,115
177E:  MOVWF  x16
1780:  CLRF   19
1782:  BTFSC  FF2.7
1784:  BSF    19.7
1786:  BCF    FF2.7
1788:  MOVFF  114,13C
178C:  MOVFF  113,13B
1790:  MOVWF  x3E
1792:  MOVFF  01,13D
1796:  MOVLB  0
1798:  CALL   02EE
179C:  BTFSC  19.7
179E:  BSF    FF2.7
17A0:  MOVFF  02,116
17A4:  MOVLB  1
17A6:  RLCF   01,W
17A8:  MOVWF  02
17AA:  RLCF   x16,W
17AC:  MOVWF  03
17AE:  RLCF   02,F
17B0:  RLCF   03,F
17B2:  MOVLW  FC
17B4:  ANDWF  02,F
17B6:  MOVFF  02,115
17BA:  MOVFF  03,116
17BE:  BCF    FD8.1
17C0:  MOVFF  48,124
17C4:  MOVFF  47,123
17C8:  MOVFF  46,122
17CC:  MOVFF  45,121
17D0:  CLRF   x28
17D2:  CLRF   x27
17D4:  MOVFF  03,126
17D8:  MOVFF  02,125
17DC:  MOVLB  0
17DE:  RCALL  1388
.................... } 
17E0:  RETURN 0
.................... void send_data(unsigned int16 data)  
.................... {  
....................  dataout[0]=make8(data,0); 
....................  dataout[1]=make8(data,1);    
....................  usb_put_packet(1, dataout, 128, USB_DTS_TOGGLE); 
.................... } 
.................... float readadc(int port)  { 
....................  set_adc_channel(port); 
*
1204:  MOVLB  1
1206:  RLCF   x11,W
1208:  MOVWF  00
120A:  RLCF   00,F
120C:  MOVLW  FC
120E:  ANDWF  00,F
1210:  MOVF   FC2,W
1212:  ANDLW  C3
1214:  IORWF  00,W
1216:  MOVWF  FC2
....................  adc=read_adc();  
1218:  BSF    FC2.1
121A:  BTFSC  FC2.1
121C:  BRA    121A
121E:  MOVFF  FC4,03
1222:  MOVFF  FC3,112
1226:  MOVFF  FC4,113
122A:  MOVLB  0
122C:  BRA    11CC
122E:  MOVFF  03,8D
1232:  MOVFF  02,8C
1236:  MOVFF  01,8B
123A:  MOVFF  00,8A
....................  return adc; 
123E:  MOVFF  8A,00
1242:  MOVFF  8B,01
1246:  MOVFF  8C,02
124A:  MOVFF  8D,03
.................... } 
124E:  RETURN 0
.................... void serigonder() 
.................... { 
.................... printf( 
.................... "%1.0f;%1.0f;%1.0f;%1.0f;"  
.................... "%1.0f;%1.0f;%1.0f;%1.0f;"  
.................... "%1.0f;%1.0f;%1.0f;%1.0f\r"  
.................... ,adc1,adc2,adc3,adc4,adc5,adc6,adc7,adc8,adc9,adc10,adc11,adc12); 
*
15BA:  MOVLW  00
15BC:  MOVWF  FE9
15BE:  MOVFF  5D,114
15C2:  MOVFF  5C,113
15C6:  MOVFF  5B,112
15CA:  MOVFF  5A,111
15CE:  MOVLB  1
15D0:  CLRF   x15
15D2:  MOVLB  0
15D4:  RCALL  141C
15D6:  MOVLW  3B
15D8:  BTFSS  F9E.4
15DA:  BRA    15D8
15DC:  MOVWF  FAD
15DE:  MOVLW  00
15E0:  MOVWF  FE9
15E2:  MOVFF  61,114
15E6:  MOVFF  60,113
15EA:  MOVFF  5F,112
15EE:  MOVFF  5E,111
15F2:  MOVLB  1
15F4:  CLRF   x15
15F6:  MOVLB  0
15F8:  RCALL  141C
15FA:  MOVLW  3B
15FC:  BTFSS  F9E.4
15FE:  BRA    15FC
1600:  MOVWF  FAD
1602:  MOVLW  00
1604:  MOVWF  FE9
1606:  MOVFF  65,114
160A:  MOVFF  64,113
160E:  MOVFF  63,112
1612:  MOVFF  62,111
1616:  MOVLB  1
1618:  CLRF   x15
161A:  MOVLB  0
161C:  RCALL  141C
161E:  MOVLW  3B
1620:  BTFSS  F9E.4
1622:  BRA    1620
1624:  MOVWF  FAD
1626:  MOVLW  00
1628:  MOVWF  FE9
162A:  MOVFF  69,114
162E:  MOVFF  68,113
1632:  MOVFF  67,112
1636:  MOVFF  66,111
163A:  MOVLB  1
163C:  CLRF   x15
163E:  MOVLB  0
1640:  RCALL  141C
1642:  MOVLW  3B
1644:  BTFSS  F9E.4
1646:  BRA    1644
1648:  MOVWF  FAD
164A:  MOVLW  00
164C:  MOVWF  FE9
164E:  MOVFF  6D,114
1652:  MOVFF  6C,113
1656:  MOVFF  6B,112
165A:  MOVFF  6A,111
165E:  MOVLB  1
1660:  CLRF   x15
1662:  MOVLB  0
1664:  RCALL  141C
1666:  MOVLW  3B
1668:  BTFSS  F9E.4
166A:  BRA    1668
166C:  MOVWF  FAD
166E:  MOVLW  00
1670:  MOVWF  FE9
1672:  MOVFF  71,114
1676:  MOVFF  70,113
167A:  MOVFF  6F,112
167E:  MOVFF  6E,111
1682:  MOVLB  1
1684:  CLRF   x15
1686:  MOVLB  0
1688:  RCALL  141C
168A:  MOVLW  3B
168C:  BTFSS  F9E.4
168E:  BRA    168C
1690:  MOVWF  FAD
1692:  MOVLW  00
1694:  MOVWF  FE9
1696:  MOVFF  75,114
169A:  MOVFF  74,113
169E:  MOVFF  73,112
16A2:  MOVFF  72,111
16A6:  MOVLB  1
16A8:  CLRF   x15
16AA:  MOVLB  0
16AC:  RCALL  141C
16AE:  MOVLW  3B
16B0:  BTFSS  F9E.4
16B2:  BRA    16B0
16B4:  MOVWF  FAD
16B6:  MOVLW  00
16B8:  MOVWF  FE9
16BA:  MOVFF  79,114
16BE:  MOVFF  78,113
16C2:  MOVFF  77,112
16C6:  MOVFF  76,111
16CA:  MOVLB  1
16CC:  CLRF   x15
16CE:  MOVLB  0
16D0:  RCALL  141C
16D2:  MOVLW  3B
16D4:  BTFSS  F9E.4
16D6:  BRA    16D4
16D8:  MOVWF  FAD
16DA:  MOVLW  00
16DC:  MOVWF  FE9
16DE:  MOVFF  7D,114
16E2:  MOVFF  7C,113
16E6:  MOVFF  7B,112
16EA:  MOVFF  7A,111
16EE:  MOVLB  1
16F0:  CLRF   x15
16F2:  MOVLB  0
16F4:  RCALL  141C
16F6:  MOVLW  3B
16F8:  BTFSS  F9E.4
16FA:  BRA    16F8
16FC:  MOVWF  FAD
16FE:  MOVLW  00
1700:  MOVWF  FE9
1702:  MOVFF  81,114
1706:  MOVFF  80,113
170A:  MOVFF  7F,112
170E:  MOVFF  7E,111
1712:  MOVLB  1
1714:  CLRF   x15
1716:  MOVLB  0
1718:  RCALL  141C
171A:  MOVLW  3B
171C:  BTFSS  F9E.4
171E:  BRA    171C
1720:  MOVWF  FAD
1722:  MOVLW  00
1724:  MOVWF  FE9
1726:  MOVFF  85,114
172A:  MOVFF  84,113
172E:  MOVFF  83,112
1732:  MOVFF  82,111
1736:  MOVLB  1
1738:  CLRF   x15
173A:  MOVLB  0
173C:  RCALL  141C
173E:  MOVLW  3B
1740:  BTFSS  F9E.4
1742:  BRA    1740
1744:  MOVWF  FAD
1746:  MOVLW  00
1748:  MOVWF  FE9
174A:  MOVFF  89,114
174E:  MOVFF  88,113
1752:  MOVFF  87,112
1756:  MOVFF  86,111
175A:  MOVLB  1
175C:  CLRF   x15
175E:  MOVLB  0
1760:  RCALL  141C
1762:  MOVLW  0D
1764:  BTFSS  F9E.4
1766:  BRA    1764
1768:  MOVWF  FAD
.................... //puts(gonderilecekveri); 
.................... }void usbgonder() 
176A:  RETURN 0
.................... { 
.................... sprintf(gonderilecekveri, 
.................... "%1.0f;%1.0f;%1.0f;%1.0f;"  
.................... "%1.0f;%1.0f;%1.0f;%1.0f;"  
.................... "%1.0f;%1.0f;%1.0f;%1.0f"  
.................... ,adc1,adc2,adc3,adc4,adc5,adc6,adc7,adc8,adc9,adc10,adc11,adc12); 
*
1E48:  MOVLB  1
1E4A:  CLRF   x0F
1E4C:  MOVLW  8E
1E4E:  MOVWF  x0E
1E50:  MOVLW  00
1E52:  MOVWF  FE9
1E54:  MOVFF  5D,114
1E58:  MOVFF  5C,113
1E5C:  MOVFF  5B,112
1E60:  MOVFF  5A,111
1E64:  CLRF   x15
1E66:  MOVLB  0
1E68:  RCALL  1BD2
1E6A:  MOVLW  3B
1E6C:  MOVLB  1
1E6E:  MOVWF  x1E
1E70:  MOVLB  0
1E72:  RCALL  1BB2
1E74:  MOVLW  00
1E76:  MOVWF  FE9
1E78:  MOVFF  61,114
1E7C:  MOVFF  60,113
1E80:  MOVFF  5F,112
1E84:  MOVFF  5E,111
1E88:  MOVLB  1
1E8A:  CLRF   x15
1E8C:  MOVLB  0
1E8E:  RCALL  1BD2
1E90:  MOVLW  3B
1E92:  MOVLB  1
1E94:  MOVWF  x1E
1E96:  MOVLB  0
1E98:  RCALL  1BB2
1E9A:  MOVLW  00
1E9C:  MOVWF  FE9
1E9E:  MOVFF  65,114
1EA2:  MOVFF  64,113
1EA6:  MOVFF  63,112
1EAA:  MOVFF  62,111
1EAE:  MOVLB  1
1EB0:  CLRF   x15
1EB2:  MOVLB  0
1EB4:  RCALL  1BD2
1EB6:  MOVLW  3B
1EB8:  MOVLB  1
1EBA:  MOVWF  x1E
1EBC:  MOVLB  0
1EBE:  RCALL  1BB2
1EC0:  MOVLW  00
1EC2:  MOVWF  FE9
1EC4:  MOVFF  69,114
1EC8:  MOVFF  68,113
1ECC:  MOVFF  67,112
1ED0:  MOVFF  66,111
1ED4:  MOVLB  1
1ED6:  CLRF   x15
1ED8:  MOVLB  0
1EDA:  RCALL  1BD2
1EDC:  MOVLW  3B
1EDE:  MOVLB  1
1EE0:  MOVWF  x1E
1EE2:  MOVLB  0
1EE4:  RCALL  1BB2
1EE6:  MOVLW  00
1EE8:  MOVWF  FE9
1EEA:  MOVFF  6D,114
1EEE:  MOVFF  6C,113
1EF2:  MOVFF  6B,112
1EF6:  MOVFF  6A,111
1EFA:  MOVLB  1
1EFC:  CLRF   x15
1EFE:  MOVLB  0
1F00:  RCALL  1BD2
1F02:  MOVLW  3B
1F04:  MOVLB  1
1F06:  MOVWF  x1E
1F08:  MOVLB  0
1F0A:  RCALL  1BB2
1F0C:  MOVLW  00
1F0E:  MOVWF  FE9
1F10:  MOVFF  71,114
1F14:  MOVFF  70,113
1F18:  MOVFF  6F,112
1F1C:  MOVFF  6E,111
1F20:  MOVLB  1
1F22:  CLRF   x15
1F24:  MOVLB  0
1F26:  RCALL  1BD2
1F28:  MOVLW  3B
1F2A:  MOVLB  1
1F2C:  MOVWF  x1E
1F2E:  MOVLB  0
1F30:  RCALL  1BB2
1F32:  MOVLW  00
1F34:  MOVWF  FE9
1F36:  MOVFF  75,114
1F3A:  MOVFF  74,113
1F3E:  MOVFF  73,112
1F42:  MOVFF  72,111
1F46:  MOVLB  1
1F48:  CLRF   x15
1F4A:  MOVLB  0
1F4C:  RCALL  1BD2
1F4E:  MOVLW  3B
1F50:  MOVLB  1
1F52:  MOVWF  x1E
1F54:  MOVLB  0
1F56:  RCALL  1BB2
1F58:  MOVLW  00
1F5A:  MOVWF  FE9
1F5C:  MOVFF  79,114
1F60:  MOVFF  78,113
1F64:  MOVFF  77,112
1F68:  MOVFF  76,111
1F6C:  MOVLB  1
1F6E:  CLRF   x15
1F70:  MOVLB  0
1F72:  RCALL  1BD2
1F74:  MOVLW  3B
1F76:  MOVLB  1
1F78:  MOVWF  x1E
1F7A:  MOVLB  0
1F7C:  RCALL  1BB2
1F7E:  MOVLW  00
1F80:  MOVWF  FE9
1F82:  MOVFF  7D,114
1F86:  MOVFF  7C,113
1F8A:  MOVFF  7B,112
1F8E:  MOVFF  7A,111
1F92:  MOVLB  1
1F94:  CLRF   x15
1F96:  MOVLB  0
1F98:  RCALL  1BD2
1F9A:  MOVLW  3B
1F9C:  MOVLB  1
1F9E:  MOVWF  x1E
1FA0:  MOVLB  0
1FA2:  RCALL  1BB2
1FA4:  MOVLW  00
1FA6:  MOVWF  FE9
1FA8:  MOVFF  81,114
1FAC:  MOVFF  80,113
1FB0:  MOVFF  7F,112
1FB4:  MOVFF  7E,111
1FB8:  MOVLB  1
1FBA:  CLRF   x15
1FBC:  MOVLB  0
1FBE:  RCALL  1BD2
1FC0:  MOVLW  3B
1FC2:  MOVLB  1
1FC4:  MOVWF  x1E
1FC6:  MOVLB  0
1FC8:  RCALL  1BB2
1FCA:  MOVLW  00
1FCC:  MOVWF  FE9
1FCE:  MOVFF  85,114
1FD2:  MOVFF  84,113
1FD6:  MOVFF  83,112
1FDA:  MOVFF  82,111
1FDE:  MOVLB  1
1FE0:  CLRF   x15
1FE2:  MOVLB  0
1FE4:  RCALL  1BD2
1FE6:  MOVLW  3B
1FE8:  MOVLB  1
1FEA:  MOVWF  x1E
1FEC:  MOVLB  0
1FEE:  RCALL  1BB2
1FF0:  MOVLW  00
1FF2:  MOVWF  FE9
1FF4:  MOVFF  89,114
1FF8:  MOVFF  88,113
1FFC:  MOVFF  87,112
2000:  MOVFF  86,111
2004:  MOVLB  1
2006:  CLRF   x15
2008:  MOVLB  0
200A:  RCALL  1BD2
.................... usb_put_packet(1, gonderilecekveri,128, USB_DTS_TOGGLE); 
200C:  MOVLW  01
200E:  MOVLB  1
2010:  MOVWF  x11
2012:  CLRF   x13
2014:  MOVLW  8E
2016:  MOVWF  x12
2018:  CLRF   x15
201A:  MOVLW  80
201C:  MOVWF  x14
201E:  MOVLW  02
2020:  MOVWF  x16
2022:  MOVLB  0
2024:  BRA    1D80
.................... } 
2026:  GOTO   2AE2 (RETURN)
....................  
.................... void main(void)  
.................... {    
202A:  CLRF   FF8
202C:  BCF    FD0.7
202E:  BSF    07.7
2030:  CLRF   FEA
2032:  CLRF   FE9
2034:  CLRF   1A
2036:  BSF    FB8.3
2038:  MOVLW  E1
203A:  MOVWF  FAF
203C:  MOVLW  04
203E:  MOVWF  FB0
2040:  MOVLW  A6
2042:  MOVWF  FAC
2044:  MOVLW  90
2046:  MOVWF  FAB
2048:  CLRF   3C
204A:  CLRF   3B
204C:  CLRF   3E
204E:  SETF   3D
2050:  CLRF   40
2052:  MOVLW  80
2054:  MOVWF  3F
2056:  CLRF   42
2058:  CLRF   41
205A:  CLRF   44
205C:  MOVLW  10
205E:  MOVWF  43
2060:  MOVLW  02
2062:  MOVWF  48
2064:  MOVLW  DC
2066:  MOVWF  47
2068:  MOVLW  6C
206A:  MOVWF  46
206C:  CLRF   45
206E:  CLRF   4B
2070:  CLRF   4C
2072:  MOVLW  01
2074:  MOVWF  4D
2076:  MOVLB  1
2078:  CLRF   x0F
207A:  CLRF   x0E
207C:  MOVF   FC1,W
207E:  ANDLW  C0
2080:  IORLW  0F
2082:  MOVWF  FC1
2084:  MOVLW  07
2086:  MOVWF  FB4
2088:  CLRF   1F
208A:  MOVLW  04
208C:  MOVWF  20
208E:  MOVLW  0C
2090:  MOVWF  21
....................       user_init();  
2092:  MOVLB  0
2094:  GOTO   116E
....................       while(TRUE)  
....................       {        
....................        if(kbhit()) 
2098:  BTFSS  F9E.5
209A:  BRA    25AC
....................        { 
....................         char key = getc();  
209C:  GOTO   11B4
20A0:  MOVFF  01,110
....................               if(key=='r') 
20A4:  MOVLB  1
20A6:  MOVF   x10,W
20A8:  SUBLW  72
20AA:  BTFSS  FD8.2
20AC:  BRA    2202
....................               {              
....................                     adc1=readadc(0); 
20AE:  CLRF   x11
20B0:  MOVLB  0
20B2:  CALL   1204
20B6:  MOVFF  03,5D
20BA:  MOVFF  02,5C
20BE:  MOVFF  01,5B
20C2:  MOVFF  00,5A
....................                     adc2=readadc(1); 
20C6:  MOVLW  01
20C8:  MOVLB  1
20CA:  MOVWF  x11
20CC:  MOVLB  0
20CE:  CALL   1204
20D2:  MOVFF  03,61
20D6:  MOVFF  02,60
20DA:  MOVFF  01,5F
20DE:  MOVFF  00,5E
....................                     adc3=readadc(3); 
20E2:  MOVLW  03
20E4:  MOVLB  1
20E6:  MOVWF  x11
20E8:  MOVLB  0
20EA:  CALL   1204
20EE:  MOVFF  03,65
20F2:  MOVFF  02,64
20F6:  MOVFF  01,63
20FA:  MOVFF  00,62
....................                     adc4=readadc(4); 
20FE:  MOVLW  04
2100:  MOVLB  1
2102:  MOVWF  x11
2104:  MOVLB  0
2106:  CALL   1204
210A:  MOVFF  03,69
210E:  MOVFF  02,68
2112:  MOVFF  01,67
2116:  MOVFF  00,66
....................                     adc5=readadc(5); 
211A:  MOVLW  05
211C:  MOVLB  1
211E:  MOVWF  x11
2120:  MOVLB  0
2122:  CALL   1204
2126:  MOVFF  03,6D
212A:  MOVFF  02,6C
212E:  MOVFF  01,6B
2132:  MOVFF  00,6A
....................                     adc6=readadc(6); 
2136:  MOVLW  06
2138:  MOVLB  1
213A:  MOVWF  x11
213C:  MOVLB  0
213E:  CALL   1204
2142:  MOVFF  03,71
2146:  MOVFF  02,70
214A:  MOVFF  01,6F
214E:  MOVFF  00,6E
....................                     adc7=readadc(7); 
2152:  MOVLW  07
2154:  MOVLB  1
2156:  MOVWF  x11
2158:  MOVLB  0
215A:  CALL   1204
215E:  MOVFF  03,75
2162:  MOVFF  02,74
2166:  MOVFF  01,73
216A:  MOVFF  00,72
....................                     adc8=readadc(8); 
216E:  MOVLW  08
2170:  MOVLB  1
2172:  MOVWF  x11
2174:  MOVLB  0
2176:  CALL   1204
217A:  MOVFF  03,79
217E:  MOVFF  02,78
2182:  MOVFF  01,77
2186:  MOVFF  00,76
....................                     adc9=readadc(9); 
218A:  MOVLW  09
218C:  MOVLB  1
218E:  MOVWF  x11
2190:  MOVLB  0
2192:  CALL   1204
2196:  MOVFF  03,7D
219A:  MOVFF  02,7C
219E:  MOVFF  01,7B
21A2:  MOVFF  00,7A
....................                     adc10=readadc(10); 
21A6:  MOVLW  0A
21A8:  MOVLB  1
21AA:  MOVWF  x11
21AC:  MOVLB  0
21AE:  CALL   1204
21B2:  MOVFF  03,81
21B6:  MOVFF  02,80
21BA:  MOVFF  01,7F
21BE:  MOVFF  00,7E
....................                     adc11=readadc(11); 
21C2:  MOVLW  0B
21C4:  MOVLB  1
21C6:  MOVWF  x11
21C8:  MOVLB  0
21CA:  CALL   1204
21CE:  MOVFF  03,85
21D2:  MOVFF  02,84
21D6:  MOVFF  01,83
21DA:  MOVFF  00,82
....................                     adc12=readadc(12);  
21DE:  MOVLW  0C
21E0:  MOVLB  1
21E2:  MOVWF  x11
21E4:  MOVLB  0
21E6:  CALL   1204
21EA:  MOVFF  03,89
21EE:  MOVFF  02,88
21F2:  MOVFF  01,87
21F6:  MOVFF  00,86
....................                     serigonder();               
21FA:  CALL   15BA
....................               // printf("Data: \%d\r\n", key);  
....................               }  
....................               else if(key=='p') 
21FE:  BRA    25AC
2200:  MOVLB  1
2202:  MOVF   x10,W
2204:  SUBLW  70
2206:  BNZ   222C
....................               { 
....................                   x = (unsigned int) pwmduty; 
2208:  MOVFF  3F,4A
....................                   setup_timer_2(T2_DIV_BY_16,pwmfreq,1);   
220C:  MOVLW  00
220E:  IORLW  06
2210:  MOVWF  FCA
2212:  MOVFF  3D,FCB
....................                   set_pwm1_duty(x);                            
2216:  MOVFF  4A,FBE
....................                   printf("PWM START\r");      
221A:  MOVLW  98
221C:  MOVWF  FF6
221E:  MOVLW  0F
2220:  MOVWF  FF7
2222:  MOVLB  0
2224:  CALL   1080
....................               } 
....................               else if(key=='1') 
2228:  BRA    25AC
222A:  MOVLB  1
222C:  MOVF   x10,W
222E:  SUBLW  31
2230:  BNZ   22F2
....................               {                  
....................                   pwmduty=pwmduty-1; 
2232:  MOVLW  01
2234:  SUBWF  3F,F
2236:  MOVLW  00
2238:  SUBWFB 40,F
....................                   if(pwmduty>255)pwmduty=255; 
223A:  MOVF   40,W
223C:  SUBLW  00
223E:  BC    2244
2240:  CLRF   40
2242:  SETF   3F
....................                   if(pwmduty<0)pwmduty=0;                         
....................                   x = (unsigned int) pwmduty; 
2244:  MOVFF  3F,4A
....................                   set_pwm1_duty(x);  
2248:  MOVFF  4A,FBE
....................                   printf("PWM:%LdDUTY:%LdFREQ:%Ld\r",pwmfreq,pwmduty,getFreq(pwmfreq,pwmmode));    
224C:  MOVFF  3E,112
2250:  MOVFF  3D,111
2254:  MOVFF  44,114
2258:  MOVFF  43,113
225C:  MOVLB  0
225E:  CALL   176C
2262:  MOVFF  03,114
2266:  MOVFF  02,113
226A:  MOVFF  01,112
226E:  MOVFF  00,111
2272:  MOVLW  A4
2274:  MOVWF  FF6
2276:  MOVLW  0F
2278:  MOVWF  FF7
227A:  MOVLW  04
227C:  MOVLB  1
227E:  MOVWF  x15
2280:  MOVLB  0
2282:  CALL   17E2
2286:  MOVLW  10
2288:  MOVWF  FE9
228A:  MOVFF  3E,116
228E:  MOVFF  3D,115
2292:  CALL   180C
2296:  MOVLW  AB
2298:  MOVWF  FF6
229A:  MOVLW  0F
229C:  MOVWF  FF7
229E:  MOVLW  05
22A0:  MOVLB  1
22A2:  MOVWF  x15
22A4:  MOVLB  0
22A6:  CALL   17E2
22AA:  MOVLW  10
22AC:  MOVWF  FE9
22AE:  MOVFF  40,116
22B2:  MOVFF  3F,115
22B6:  CALL   180C
22BA:  MOVLW  B3
22BC:  MOVWF  FF6
22BE:  MOVLW  0F
22C0:  MOVWF  FF7
22C2:  MOVLW  05
22C4:  MOVLB  1
22C6:  MOVWF  x15
22C8:  MOVLB  0
22CA:  CALL   17E2
22CE:  MOVLW  41
22D0:  MOVWF  FE9
22D2:  MOVFF  114,118
22D6:  MOVFF  113,117
22DA:  MOVFF  112,116
22DE:  MOVFF  111,115
22E2:  CALL   18EE
22E6:  MOVLW  0D
22E8:  BTFSS  F9E.4
22EA:  BRA    22E8
22EC:  MOVWF  FAD
....................               } 
....................                else if(key=='2') 
22EE:  BRA    25AC
22F0:  MOVLB  1
22F2:  MOVF   x10,W
22F4:  SUBLW  32
22F6:  BNZ   23B8
....................               {                  
....................                   pwmduty=pwmduty+1; 
22F8:  MOVLW  01
22FA:  ADDWF  3F,F
22FC:  MOVLW  00
22FE:  ADDWFC 40,F
....................                   if(pwmduty>255)pwmduty=255; 
2300:  MOVF   40,W
2302:  SUBLW  00
2304:  BC    230A
2306:  CLRF   40
2308:  SETF   3F
....................                   if(pwmduty<0)pwmduty=0;                         
....................                   x = (unsigned int) pwmduty; 
230A:  MOVFF  3F,4A
....................                   set_pwm1_duty(x);  
230E:  MOVFF  4A,FBE
....................                   printf("PWM:%LdDUTY:%LdFREQ:%Ld\r",pwmfreq,pwmduty,getFreq(pwmfreq,pwmmode));    
2312:  MOVFF  3E,112
2316:  MOVFF  3D,111
231A:  MOVFF  44,114
231E:  MOVFF  43,113
2322:  MOVLB  0
2324:  CALL   176C
2328:  MOVFF  03,114
232C:  MOVFF  02,113
2330:  MOVFF  01,112
2334:  MOVFF  00,111
2338:  MOVLW  BE
233A:  MOVWF  FF6
233C:  MOVLW  0F
233E:  MOVWF  FF7
2340:  MOVLW  04
2342:  MOVLB  1
2344:  MOVWF  x15
2346:  MOVLB  0
2348:  CALL   17E2
234C:  MOVLW  10
234E:  MOVWF  FE9
2350:  MOVFF  3E,116
2354:  MOVFF  3D,115
2358:  CALL   180C
235C:  MOVLW  C5
235E:  MOVWF  FF6
2360:  MOVLW  0F
2362:  MOVWF  FF7
2364:  MOVLW  05
2366:  MOVLB  1
2368:  MOVWF  x15
236A:  MOVLB  0
236C:  CALL   17E2
2370:  MOVLW  10
2372:  MOVWF  FE9
2374:  MOVFF  40,116
2378:  MOVFF  3F,115
237C:  CALL   180C
2380:  MOVLW  CD
2382:  MOVWF  FF6
2384:  MOVLW  0F
2386:  MOVWF  FF7
2388:  MOVLW  05
238A:  MOVLB  1
238C:  MOVWF  x15
238E:  MOVLB  0
2390:  CALL   17E2
2394:  MOVLW  41
2396:  MOVWF  FE9
2398:  MOVFF  114,118
239C:  MOVFF  113,117
23A0:  MOVFF  112,116
23A4:  MOVFF  111,115
23A8:  CALL   18EE
23AC:  MOVLW  0D
23AE:  BTFSS  F9E.4
23B0:  BRA    23AE
23B2:  MOVWF  FAD
....................               } 
....................               else if(key=='3') 
23B4:  BRA    25AC
23B6:  MOVLB  1
23B8:  MOVF   x10,W
23BA:  SUBLW  33
23BC:  BNZ   249C
....................               { 
....................                 pwmfreq=pwmfreq-1; 
23BE:  MOVLW  01
23C0:  SUBWF  3D,F
23C2:  MOVLW  00
23C4:  SUBWFB 3E,F
....................                 pwmduty=pwmfreq/2; 
23C6:  BCF    FD8.0
23C8:  RRCF   3E,W
23CA:  MOVWF  40
23CC:  RRCF   3D,W
23CE:  MOVWF  3F
....................                 if(pwmfreq>255)pwmfreq=255; 
23D0:  MOVF   3E,W
23D2:  SUBLW  00
23D4:  BC    23DA
23D6:  CLRF   3E
23D8:  SETF   3D
....................                 if(pwmfreq<0)pwmfreq=0;  
....................                 if(pwmduty>255)pwmduty=255; 
23DA:  MOVF   40,W
23DC:  SUBLW  00
23DE:  BC    23E4
23E0:  CLRF   40
23E2:  SETF   3F
....................                 if(pwmduty<0)pwmduty=0;                         
....................                   x = (unsigned int) pwmduty; 
23E4:  MOVFF  3F,4A
....................                   set_pwm1_duty(x);  
23E8:  MOVFF  4A,FBE
....................                   setup_timer_2(T2_DIV_BY_16,pwmfreq,1);   
23EC:  MOVLW  00
23EE:  IORLW  06
23F0:  MOVWF  FCA
23F2:  MOVFF  3D,FCB
....................                   printf("PWM:%LdDUTY:%LdFREQ:%Ld\r",pwmfreq,pwmduty,getFreq(pwmfreq,pwmmode));      
23F6:  MOVFF  3E,112
23FA:  MOVFF  3D,111
23FE:  MOVFF  44,114
2402:  MOVFF  43,113
2406:  MOVLB  0
2408:  CALL   176C
240C:  MOVFF  03,114
2410:  MOVFF  02,113
2414:  MOVFF  01,112
2418:  MOVFF  00,111
241C:  MOVLW  D8
241E:  MOVWF  FF6
2420:  MOVLW  0F
2422:  MOVWF  FF7
2424:  MOVLW  04
2426:  MOVLB  1
2428:  MOVWF  x15
242A:  MOVLB  0
242C:  CALL   17E2
2430:  MOVLW  10
2432:  MOVWF  FE9
2434:  MOVFF  3E,116
2438:  MOVFF  3D,115
243C:  CALL   180C
2440:  MOVLW  DF
2442:  MOVWF  FF6
2444:  MOVLW  0F
2446:  MOVWF  FF7
2448:  MOVLW  05
244A:  MOVLB  1
244C:  MOVWF  x15
244E:  MOVLB  0
2450:  CALL   17E2
2454:  MOVLW  10
2456:  MOVWF  FE9
2458:  MOVFF  40,116
245C:  MOVFF  3F,115
2460:  CALL   180C
2464:  MOVLW  E7
2466:  MOVWF  FF6
2468:  MOVLW  0F
246A:  MOVWF  FF7
246C:  MOVLW  05
246E:  MOVLB  1
2470:  MOVWF  x15
2472:  MOVLB  0
2474:  CALL   17E2
2478:  MOVLW  41
247A:  MOVWF  FE9
247C:  MOVFF  114,118
2480:  MOVFF  113,117
2484:  MOVFF  112,116
2488:  MOVFF  111,115
248C:  CALL   18EE
2490:  MOVLW  0D
2492:  BTFSS  F9E.4
2494:  BRA    2492
2496:  MOVWF  FAD
....................               } 
....................               else if(key=='4') 
2498:  BRA    25AC
249A:  MOVLB  1
249C:  MOVF   x10,W
249E:  SUBLW  34
24A0:  BNZ   2580
....................               { 
....................                 pwmfreq=pwmfreq+1; 
24A2:  MOVLW  01
24A4:  ADDWF  3D,F
24A6:  MOVLW  00
24A8:  ADDWFC 3E,F
....................                 pwmduty=pwmfreq/2; 
24AA:  BCF    FD8.0
24AC:  RRCF   3E,W
24AE:  MOVWF  40
24B0:  RRCF   3D,W
24B2:  MOVWF  3F
....................                 if(pwmfreq>255)pwmfreq=255; 
24B4:  MOVF   3E,W
24B6:  SUBLW  00
24B8:  BC    24BE
24BA:  CLRF   3E
24BC:  SETF   3D
....................                 if(pwmfreq<0)pwmfreq=0;  
....................                 if(pwmduty>255)pwmduty=255; 
24BE:  MOVF   40,W
24C0:  SUBLW  00
24C2:  BC    24C8
24C4:  CLRF   40
24C6:  SETF   3F
....................                 if(pwmduty<0)pwmduty=0;                         
....................                   x = (unsigned int) pwmduty; 
24C8:  MOVFF  3F,4A
....................                   set_pwm1_duty(x);      
24CC:  MOVFF  4A,FBE
....................                   setup_timer_2(T2_DIV_BY_16,pwmfreq,1);   
24D0:  MOVLW  00
24D2:  IORLW  06
24D4:  MOVWF  FCA
24D6:  MOVFF  3D,FCB
....................                   printf("PWM:%LdDUTY:%LdFREQ:%Ld\r",pwmfreq,pwmduty,getFreq(pwmfreq,pwmmode));    
24DA:  MOVFF  3E,112
24DE:  MOVFF  3D,111
24E2:  MOVFF  44,114
24E6:  MOVFF  43,113
24EA:  MOVLB  0
24EC:  CALL   176C
24F0:  MOVFF  03,114
24F4:  MOVFF  02,113
24F8:  MOVFF  01,112
24FC:  MOVFF  00,111
2500:  MOVLW  F2
2502:  MOVWF  FF6
2504:  MOVLW  0F
2506:  MOVWF  FF7
2508:  MOVLW  04
250A:  MOVLB  1
250C:  MOVWF  x15
250E:  MOVLB  0
2510:  CALL   17E2
2514:  MOVLW  10
2516:  MOVWF  FE9
2518:  MOVFF  3E,116
251C:  MOVFF  3D,115
2520:  CALL   180C
2524:  MOVLW  F9
2526:  MOVWF  FF6
2528:  MOVLW  0F
252A:  MOVWF  FF7
252C:  MOVLW  05
252E:  MOVLB  1
2530:  MOVWF  x15
2532:  MOVLB  0
2534:  CALL   17E2
2538:  MOVLW  10
253A:  MOVWF  FE9
253C:  MOVFF  40,116
2540:  MOVFF  3F,115
2544:  CALL   180C
2548:  MOVLW  01
254A:  MOVWF  FF6
254C:  MOVLW  10
254E:  MOVWF  FF7
2550:  MOVLW  05
2552:  MOVLB  1
2554:  MOVWF  x15
2556:  MOVLB  0
2558:  CALL   17E2
255C:  MOVLW  41
255E:  MOVWF  FE9
2560:  MOVFF  114,118
2564:  MOVFF  113,117
2568:  MOVFF  112,116
256C:  MOVFF  111,115
2570:  CALL   18EE
2574:  MOVLW  0D
2576:  BTFSS  F9E.4
2578:  BRA    2576
257A:  MOVWF  FAD
....................               } 
....................               else if(key=='s') 
257C:  BRA    25AC
257E:  MOVLB  1
2580:  MOVF   x10,W
2582:  SUBLW  73
2584:  BNZ   25A0
....................               { 
....................                   set_pwm1_duty(0L);                           
2586:  CLRF   FBE
2588:  MOVF   FBD,W
258A:  ANDLW  CF
258C:  MOVWF  FBD
....................                   printf("PWM STOP\r");  
258E:  MOVLW  0C
2590:  MOVWF  FF6
2592:  MOVLW  10
2594:  MOVWF  FF7
2596:  MOVLB  0
2598:  CALL   1080
....................               } 
....................               else if(key=='u') 
259C:  BRA    25AC
259E:  MOVLB  1
25A0:  MOVF   x10,W
25A2:  SUBLW  75
25A4:  BNZ   25AE
....................               { 
....................                try_usb(); 
25A6:  MOVLB  0
25A8:  CALL   1136
25AC:  MOVLB  1
....................               } 
....................        } 
....................        if (usb_kbhit(1))             //Eer pc'den yeni bir paket geldiyse 
25AE:  MOVLW  01
25B0:  MOVWF  x11
25B2:  MOVLB  0
25B4:  GOTO   19FC
25B8:  MOVF   01,F
25BA:  BTFSC  FD8.2
25BC:  BRA    2AE2
....................                {              
....................                      usb_get_packet(1, datain, 8); //paketi oku     
25BE:  MOVLW  01
25C0:  MOVLB  1
25C2:  MOVWF  x11
25C4:  CLRF   x13
25C6:  MOVLW  2B
25C8:  MOVWF  x12
25CA:  CLRF   x15
25CC:  MOVLW  08
25CE:  MOVWF  x14
25D0:  MOVLB  0
25D2:  GOTO   1B68
....................                     // printf("\r\nPaket1: %d",datain[0]);   
....................                      switch(datain[0])             
....................                      { 
25D6:  MOVF   2B,W
25D8:  XORLW  63
25DA:  BZ    2604
25DC:  XORLW  06
25DE:  BZ    2612
25E0:  XORLW  10
25E2:  BZ    2620
25E4:  XORLW  05
25E6:  BTFSC  FD8.2
25E8:  BRA    2774
25EA:  XORLW  03
25EC:  BTFSC  FD8.2
25EE:  BRA    27CE
25F0:  XORLW  17
25F2:  BTFSC  FD8.2
25F4:  BRA    27E4
25F6:  XORLW  02
25F8:  BTFSC  FD8.2
25FA:  BRA    289E
25FC:  XORLW  14
25FE:  BTFSC  FD8.2
2600:  BRA    298E
2602:  BRA    2AE2
....................                         case 'c': 
....................                         {                   
....................                             printf("PC CONNECTED\r");                              
2604:  MOVLW  16
2606:  MOVWF  FF6
2608:  MOVLW  10
260A:  MOVWF  FF7
260C:  CALL   1080
....................                             break; 
2610:  BRA    2AE2
....................                         }   
....................                         case 'e': 
....................                         {                   
....................                             printf("PC DISCONNECTED\r");                              
2612:  MOVLW  24
2614:  MOVWF  FF6
2616:  MOVLW  10
2618:  MOVWF  FF7
261A:  CALL   1080
....................                             break; 
261E:  BRA    2AE2
....................                         }    
....................                        case 'u': 
....................                         {  
....................                              adc1=readadc(0); 
2620:  MOVLB  1
2622:  CLRF   x11
2624:  MOVLB  0
2626:  CALL   1204
262A:  MOVFF  03,5D
262E:  MOVFF  02,5C
2632:  MOVFF  01,5B
2636:  MOVFF  00,5A
....................                              adc2=readadc(1); 
263A:  MOVLW  01
263C:  MOVLB  1
263E:  MOVWF  x11
2640:  MOVLB  0
2642:  CALL   1204
2646:  MOVFF  03,61
264A:  MOVFF  02,60
264E:  MOVFF  01,5F
2652:  MOVFF  00,5E
....................                              adc3=readadc(3); 
2656:  MOVLW  03
2658:  MOVLB  1
265A:  MOVWF  x11
265C:  MOVLB  0
265E:  CALL   1204
2662:  MOVFF  03,65
2666:  MOVFF  02,64
266A:  MOVFF  01,63
266E:  MOVFF  00,62
....................                              adc4=readadc(4); 
2672:  MOVLW  04
2674:  MOVLB  1
2676:  MOVWF  x11
2678:  MOVLB  0
267A:  CALL   1204
267E:  MOVFF  03,69
2682:  MOVFF  02,68
2686:  MOVFF  01,67
268A:  MOVFF  00,66
....................                              adc5=readadc(5); 
268E:  MOVLW  05
2690:  MOVLB  1
2692:  MOVWF  x11
2694:  MOVLB  0
2696:  CALL   1204
269A:  MOVFF  03,6D
269E:  MOVFF  02,6C
26A2:  MOVFF  01,6B
26A6:  MOVFF  00,6A
....................                              adc6=readadc(6); 
26AA:  MOVLW  06
26AC:  MOVLB  1
26AE:  MOVWF  x11
26B0:  MOVLB  0
26B2:  CALL   1204
26B6:  MOVFF  03,71
26BA:  MOVFF  02,70
26BE:  MOVFF  01,6F
26C2:  MOVFF  00,6E
....................                              adc7=readadc(7); 
26C6:  MOVLW  07
26C8:  MOVLB  1
26CA:  MOVWF  x11
26CC:  MOVLB  0
26CE:  CALL   1204
26D2:  MOVFF  03,75
26D6:  MOVFF  02,74
26DA:  MOVFF  01,73
26DE:  MOVFF  00,72
....................                              adc8=readadc(8); 
26E2:  MOVLW  08
26E4:  MOVLB  1
26E6:  MOVWF  x11
26E8:  MOVLB  0
26EA:  CALL   1204
26EE:  MOVFF  03,79
26F2:  MOVFF  02,78
26F6:  MOVFF  01,77
26FA:  MOVFF  00,76
....................                              adc9=readadc(9); 
26FE:  MOVLW  09
2700:  MOVLB  1
2702:  MOVWF  x11
2704:  MOVLB  0
2706:  CALL   1204
270A:  MOVFF  03,7D
270E:  MOVFF  02,7C
2712:  MOVFF  01,7B
2716:  MOVFF  00,7A
....................                              adc10=readadc(10); 
271A:  MOVLW  0A
271C:  MOVLB  1
271E:  MOVWF  x11
2720:  MOVLB  0
2722:  CALL   1204
2726:  MOVFF  03,81
272A:  MOVFF  02,80
272E:  MOVFF  01,7F
2732:  MOVFF  00,7E
....................                              adc11=readadc(11); 
2736:  MOVLW  0B
2738:  MOVLB  1
273A:  MOVWF  x11
273C:  MOVLB  0
273E:  CALL   1204
2742:  MOVFF  03,85
2746:  MOVFF  02,84
274A:  MOVFF  01,83
274E:  MOVFF  00,82
....................                              adc12=readadc(12);  
2752:  MOVLW  0C
2754:  MOVLB  1
2756:  MOVWF  x11
2758:  MOVLB  0
275A:  CALL   1204
275E:  MOVFF  03,89
2762:  MOVFF  02,88
2766:  MOVFF  01,87
276A:  MOVFF  00,86
....................                              usbgonder();                                                         
276E:  GOTO   1E48
....................                             break; 
2772:  BRA    2AE2
....................                         }          
....................                         case 'p': 
....................                         {                          
....................                            x = (unsigned int) pwmduty; 
2774:  MOVFF  3F,4A
....................                            pwmmode=datain[1]; 
2778:  CLRF   44
277A:  MOVFF  2C,43
....................                            if(pwmmode==1) 
277E:  DECFSZ 43,W
2780:  BRA    2792
2782:  MOVF   44,F
2784:  BNZ   2792
....................                            setup_timer_2(T2_DIV_BY_1,pwmfreq,1);   
2786:  MOVLW  00
2788:  IORLW  04
278A:  MOVWF  FCA
278C:  MOVFF  3D,FCB
....................                            else if(pwmmode==4) 
2790:  BRA    27BC
2792:  MOVF   43,W
2794:  SUBLW  04
2796:  BNZ   27A8
2798:  MOVF   44,F
279A:  BNZ   27A8
....................                            setup_timer_2(T2_DIV_BY_4,pwmfreq,1);                              
279C:  MOVLW  00
279E:  IORLW  05
27A0:  MOVWF  FCA
27A2:  MOVFF  3D,FCB
....................                            else if(pwmmode==16) 
27A6:  BRA    27BC
27A8:  MOVF   43,W
27AA:  SUBLW  10
27AC:  BNZ   27BC
27AE:  MOVF   44,F
27B0:  BNZ   27BC
....................                            setup_timer_2(T2_DIV_BY_16,pwmfreq,1);   
27B2:  MOVLW  00
27B4:  IORLW  06
27B6:  MOVWF  FCA
27B8:  MOVFF  3D,FCB
....................                            set_pwm1_duty(x);                            
27BC:  MOVFF  4A,FBE
....................                            printf("PWM START\r");                           
27C0:  MOVLW  36
27C2:  MOVWF  FF6
27C4:  MOVLW  10
27C6:  MOVWF  FF7
27C8:  CALL   1080
....................                            break; 
27CC:  BRA    2AE2
....................                         }                         
....................                         case 's': 
....................                         {  
....................                            set_pwm1_duty(0L);                           
27CE:  CLRF   FBE
27D0:  MOVF   FBD,W
27D2:  ANDLW  CF
27D4:  MOVWF  FBD
....................                            printf("PWM STOP\r");                            
27D6:  MOVLW  42
27D8:  MOVWF  FF6
27DA:  MOVLW  10
27DC:  MOVWF  FF7
27DE:  CALL   1080
....................                            break; 
27E2:  BRA    2AE2
....................                         }                                         
....................                         case 'd': 
....................                         {  
....................                          pwmduty=datain[1]; 
27E4:  CLRF   40
27E6:  MOVFF  2C,3F
....................                          if(pwmduty>255)pwmduty=255; 
27EA:  MOVF   40,W
27EC:  SUBLW  00
27EE:  BC    27F4
27F0:  CLRF   40
27F2:  SETF   3F
....................                          if(pwmduty<0)pwmduty=0;                         
....................                          x = (unsigned int) pwmduty; 
27F4:  MOVFF  3F,4A
....................                          set_pwm1_duty(x);  
27F8:  MOVFF  4A,FBE
....................                          printf("PWM:%LdDUTY:%LdFREQ:%Ld\r",pwmfreq,pwmduty,getFreq(pwmfreq,pwmmode));                             
27FC:  MOVFF  3E,112
2800:  MOVFF  3D,111
2804:  MOVFF  44,114
2808:  MOVFF  43,113
280C:  CALL   176C
2810:  MOVFF  03,114
2814:  MOVFF  02,113
2818:  MOVFF  01,112
281C:  MOVFF  00,111
2820:  MOVLW  4C
2822:  MOVWF  FF6
2824:  MOVLW  10
2826:  MOVWF  FF7
2828:  MOVLW  04
282A:  MOVLB  1
282C:  MOVWF  x15
282E:  MOVLB  0
2830:  CALL   17E2
2834:  MOVLW  10
2836:  MOVWF  FE9
2838:  MOVFF  3E,116
283C:  MOVFF  3D,115
2840:  CALL   180C
2844:  MOVLW  53
2846:  MOVWF  FF6
2848:  MOVLW  10
284A:  MOVWF  FF7
284C:  MOVLW  05
284E:  MOVLB  1
2850:  MOVWF  x15
2852:  MOVLB  0
2854:  CALL   17E2
2858:  MOVLW  10
285A:  MOVWF  FE9
285C:  MOVFF  40,116
2860:  MOVFF  3F,115
2864:  CALL   180C
2868:  MOVLW  5B
286A:  MOVWF  FF6
286C:  MOVLW  10
286E:  MOVWF  FF7
2870:  MOVLW  05
2872:  MOVLB  1
2874:  MOVWF  x15
2876:  MOVLB  0
2878:  CALL   17E2
287C:  MOVLW  41
287E:  MOVWF  FE9
2880:  MOVFF  114,118
2884:  MOVFF  113,117
2888:  MOVFF  112,116
288C:  MOVFF  111,115
2890:  CALL   18EE
2894:  MOVLW  0D
2896:  BTFSS  F9E.4
2898:  BRA    2896
289A:  MOVWF  FAD
....................                            break; 
289C:  BRA    2AE2
....................                         } 
....................                         case 'f': 
....................                         {                            
....................                          pwmfreq=datain[1]; 
289E:  CLRF   3E
28A0:  MOVFF  2C,3D
....................                          if(pwmfreq>255)pwmfreq=255; 
28A4:  MOVF   3E,W
28A6:  SUBLW  00
28A8:  BC    28AE
28AA:  CLRF   3E
28AC:  SETF   3D
....................                          if(pwmfreq<0)pwmfreq=0;                         
....................                          if(pwmmode==1) 
28AE:  DECFSZ 43,W
28B0:  BRA    28C2
28B2:  MOVF   44,F
28B4:  BNZ   28C2
....................                            setup_timer_2(T2_DIV_BY_1,pwmfreq,1);   
28B6:  MOVLW  00
28B8:  IORLW  04
28BA:  MOVWF  FCA
28BC:  MOVFF  3D,FCB
....................                            else if(pwmmode==4) 
28C0:  BRA    28EC
28C2:  MOVF   43,W
28C4:  SUBLW  04
28C6:  BNZ   28D8
28C8:  MOVF   44,F
28CA:  BNZ   28D8
....................                            setup_timer_2(T2_DIV_BY_4,pwmfreq,1);                              
28CC:  MOVLW  00
28CE:  IORLW  05
28D0:  MOVWF  FCA
28D2:  MOVFF  3D,FCB
....................                            else if(pwmmode==16) 
28D6:  BRA    28EC
28D8:  MOVF   43,W
28DA:  SUBLW  10
28DC:  BNZ   28EC
28DE:  MOVF   44,F
28E0:  BNZ   28EC
....................                            setup_timer_2(T2_DIV_BY_16,pwmfreq,1);   
28E2:  MOVLW  00
28E4:  IORLW  06
28E6:  MOVWF  FCA
28E8:  MOVFF  3D,FCB
....................                            printf("PWM:%LdDUTY:%LdFREQ:%Ld\r",pwmfreq,pwmduty,getFreq(pwmfreq,pwmmode));                            
28EC:  MOVFF  3E,112
28F0:  MOVFF  3D,111
28F4:  MOVFF  44,114
28F8:  MOVFF  43,113
28FC:  CALL   176C
2900:  MOVFF  03,114
2904:  MOVFF  02,113
2908:  MOVFF  01,112
290C:  MOVFF  00,111
2910:  MOVLW  66
2912:  MOVWF  FF6
2914:  MOVLW  10
2916:  MOVWF  FF7
2918:  MOVLW  04
291A:  MOVLB  1
291C:  MOVWF  x15
291E:  MOVLB  0
2920:  CALL   17E2
2924:  MOVLW  10
2926:  MOVWF  FE9
2928:  MOVFF  3E,116
292C:  MOVFF  3D,115
2930:  CALL   180C
2934:  MOVLW  6D
2936:  MOVWF  FF6
2938:  MOVLW  10
293A:  MOVWF  FF7
293C:  MOVLW  05
293E:  MOVLB  1
2940:  MOVWF  x15
2942:  MOVLB  0
2944:  CALL   17E2
2948:  MOVLW  10
294A:  MOVWF  FE9
294C:  MOVFF  40,116
2950:  MOVFF  3F,115
2954:  CALL   180C
2958:  MOVLW  75
295A:  MOVWF  FF6
295C:  MOVLW  10
295E:  MOVWF  FF7
2960:  MOVLW  05
2962:  MOVLB  1
2964:  MOVWF  x15
2966:  MOVLB  0
2968:  CALL   17E2
296C:  MOVLW  41
296E:  MOVWF  FE9
2970:  MOVFF  114,118
2974:  MOVFF  113,117
2978:  MOVFF  112,116
297C:  MOVFF  111,115
2980:  CALL   18EE
2984:  MOVLW  0D
2986:  BTFSS  F9E.4
2988:  BRA    2986
298A:  MOVWF  FAD
....................                            break; 
298C:  BRA    2AE2
....................                         } 
....................                        case 'r': 
....................                         { 
....................                           adc1=readadc(0); 
298E:  MOVLB  1
2990:  CLRF   x11
2992:  MOVLB  0
2994:  CALL   1204
2998:  MOVFF  03,5D
299C:  MOVFF  02,5C
29A0:  MOVFF  01,5B
29A4:  MOVFF  00,5A
....................                           adc2=readadc(1); 
29A8:  MOVLW  01
29AA:  MOVLB  1
29AC:  MOVWF  x11
29AE:  MOVLB  0
29B0:  CALL   1204
29B4:  MOVFF  03,61
29B8:  MOVFF  02,60
29BC:  MOVFF  01,5F
29C0:  MOVFF  00,5E
....................                           adc3=readadc(3); 
29C4:  MOVLW  03
29C6:  MOVLB  1
29C8:  MOVWF  x11
29CA:  MOVLB  0
29CC:  CALL   1204
29D0:  MOVFF  03,65
29D4:  MOVFF  02,64
29D8:  MOVFF  01,63
29DC:  MOVFF  00,62
....................                           adc4=readadc(4); 
29E0:  MOVLW  04
29E2:  MOVLB  1
29E4:  MOVWF  x11
29E6:  MOVLB  0
29E8:  CALL   1204
29EC:  MOVFF  03,69
29F0:  MOVFF  02,68
29F4:  MOVFF  01,67
29F8:  MOVFF  00,66
....................                           adc5=readadc(5); 
29FC:  MOVLW  05
29FE:  MOVLB  1
2A00:  MOVWF  x11
2A02:  MOVLB  0
2A04:  CALL   1204
2A08:  MOVFF  03,6D
2A0C:  MOVFF  02,6C
2A10:  MOVFF  01,6B
2A14:  MOVFF  00,6A
....................                           adc6=readadc(6); 
2A18:  MOVLW  06
2A1A:  MOVLB  1
2A1C:  MOVWF  x11
2A1E:  MOVLB  0
2A20:  CALL   1204
2A24:  MOVFF  03,71
2A28:  MOVFF  02,70
2A2C:  MOVFF  01,6F
2A30:  MOVFF  00,6E
....................                           adc7=readadc(7); 
2A34:  MOVLW  07
2A36:  MOVLB  1
2A38:  MOVWF  x11
2A3A:  MOVLB  0
2A3C:  CALL   1204
2A40:  MOVFF  03,75
2A44:  MOVFF  02,74
2A48:  MOVFF  01,73
2A4C:  MOVFF  00,72
....................                           adc8=readadc(8); 
2A50:  MOVLW  08
2A52:  MOVLB  1
2A54:  MOVWF  x11
2A56:  MOVLB  0
2A58:  CALL   1204
2A5C:  MOVFF  03,79
2A60:  MOVFF  02,78
2A64:  MOVFF  01,77
2A68:  MOVFF  00,76
....................                           adc9=readadc(9); 
2A6C:  MOVLW  09
2A6E:  MOVLB  1
2A70:  MOVWF  x11
2A72:  MOVLB  0
2A74:  CALL   1204
2A78:  MOVFF  03,7D
2A7C:  MOVFF  02,7C
2A80:  MOVFF  01,7B
2A84:  MOVFF  00,7A
....................                           adc10=readadc(10); 
2A88:  MOVLW  0A
2A8A:  MOVLB  1
2A8C:  MOVWF  x11
2A8E:  MOVLB  0
2A90:  CALL   1204
2A94:  MOVFF  03,81
2A98:  MOVFF  02,80
2A9C:  MOVFF  01,7F
2AA0:  MOVFF  00,7E
....................                           adc11=readadc(11); 
2AA4:  MOVLW  0B
2AA6:  MOVLB  1
2AA8:  MOVWF  x11
2AAA:  MOVLB  0
2AAC:  CALL   1204
2AB0:  MOVFF  03,85
2AB4:  MOVFF  02,84
2AB8:  MOVFF  01,83
2ABC:  MOVFF  00,82
....................                           adc12=readadc(12);  
2AC0:  MOVLW  0C
2AC2:  MOVLB  1
2AC4:  MOVWF  x11
2AC6:  MOVLB  0
2AC8:  CALL   1204
2ACC:  MOVFF  03,89
2AD0:  MOVFF  02,88
2AD4:  MOVFF  01,87
2AD8:  MOVFF  00,86
....................                           serigonder();                                    
2ADC:  CALL   15BA
....................                          break; 
2AE0:  BRA    2AE2
....................                         }  
....................                         default: 
....................                         {                           
....................                          break; 
....................                      }                         
....................                   }                          
....................                }   
....................       }  
2AE2:  GOTO   2098
....................   
.................... }  
....................      
....................                                
....................  
....................    
2AE6:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
